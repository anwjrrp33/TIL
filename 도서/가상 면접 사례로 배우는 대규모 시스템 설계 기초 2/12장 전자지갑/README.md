# 12장 : 전자 지갑

# 12장 전자지갑

## **1단계: 문제 이해 및 설계 범위 확정**

- 두 전자 지갑 사이간 금액을 이체하는 시스템 설계
- 예상 TPS는? => 1,000,000TPS (wow;)
- 99.99%의 안정성
- 트랜잭션 지원
- 재현성(검증, 감사용)

### **개략적 추정**

- 데이터베이스 노드 수 결정하기
    - 데이터베이스 노드 하나가 1000TPS 를 지원한다고 가정했을때 1백만 TPS를 지원하려면 1000개의 데이터베이스가 필요하다?
    - => 일반적으로 송금의 경우 A계좌에서 인출(1), B계좌에 입금(2) 하는 구조이므로 1백만 TPS를 소화하려면 2000개의 노드가 필요하다.
    - 성능을 높여서 하드웨어 비용을 낮추는것도 중요한 목표이기때문에 단일 노드가 처리할 수 있는 트랜잭션 수를 늘려서 노드수를 최대한 낮춰야한다.

## **2단계: 계략적 설계안 제시 및 동의 구하기**

### **API 설계**

- `POST /v1/wallet/balance_transfer`
    - 한 지갑에서 다른 지갑으로 자금 이체

| 필드 | 설명 | 자료형 |
| --- | --- | --- |
| from_account | 자금을 인출할 계좌 | string |
| to_account | 자금을 이체할 계좌 | string |
| amount | 이체할 금액 | string |
| currency | 통화 단위 | string |
| transcation_id | 중복제거에 사용할 id | uuid |

> amount 필드는 정밀도때문에 string으로 저장한다.
> 

### **인메모리 샤딩**

- 지갑은 모든 사용자 계정의 잔액을 유지하므로 **<사용자, 잔액>** 관계를 해시테이블로 표현하기 좋다.
- 인메모리 + 해시테이블로 레디스를 선택해볼만하다.
- 100만 TPS를 처리해야하기때문에 레디스 클러스터를 구성하고 사용자 계정을 모든 노드에 균등하게 분산시켜야한다.

```
# 키-값 데이터를 n개의 파티션에 고르게 분배하는 방법 => 모듈러 샤딩

String acountId = "A";
Int partitionNumber = 7;
Int myPartition = accountId.hashCode() % partitionNumber

```

- 모든 레디스 노드의 파티션 수 및 주소는 높은 가용성을 보장하는 설정 정보 전문 저장소 주키퍼를 사용하면 좋다.
- 모든 이체명령 처리를 담당하는 지갑서비스 까지 추가하면 아래와 같다.

⇒ 하지만 레디스는 트랜잭션을 지원하지 않으므로 결제, 송금서비스에서 레디스는 좋은 방법이 아니다.

⇒ 송금연산은 원자적 트랜잭션으로 실행되어야한다.

### **분산 트랜잭션**

**데이터베이스 샤딩**

- 아직 풀리지 않은 문제
    - 한 이체 명령이 다른 두 데이터베이스 서버에 있는 계정 두 개를 업데이트해야 할때도 원자적으로 실행되어야한다.
- 분산 트랜잭션 종류
    - 2단계 커밋
    - TC/C
    - Saga

**분산 트랜잭션: 2단계 커밋**

- 분산 시스템에서 한 트랜잭션에는 여러 노드의 프로세스가 관여할 수 있다.
- 2단계 커밋 방법은 저수준 방안으로, 이름으로 알 수 있듯, 두 단계로 실행된다.

1. 조정자(지갑 서비스)는 여러 데이터베이스에 읽기 및 쓰기 작업을 직접 수행한다. 그 결과로 데이터베이스 A, C에는 락이 걸린다.
2. 첫 번째 단계에서 조정자는 모든 데이터베이스에 트랜잭션 준비를 요청한다.
3. 두 번째 단계에서 조정자는 모든 데이터베이스의 응답을 받아 다음 절차를 수행한다.
    1. 모든 데이터베이스가 OK일때 조정자는 모든 데이터베이스에 해당 트랜잭션 커밋을 요청한다.
    2. 어느 한 데이터베이스라도 NO면 조정자는 모든 데이터베이스에 트랜잭션 중단을 요청한다.
- 2단계 커밋의 단점
    - 이기종 데이터베이스라면 모든 데이터베이스가 X/Open XA 표준을 만족해야 한다.
    - 다른 노드의 메시지를 기다리는 동안 락이 걸린다.
    - 조정자가 SPOF가 될 수 있다.

> X/Open XA
> 
> - X/Open XA는 분산 트랜잭션 관리를 위한 표준 인터페이스.
> - 여러 데이터베이스와 시스템 간 트랜잭션 일관성 유지.
> - 데이터베이스 관리 시스템(DBMS)과 트랜잭션 모니터(TP Monitor) 간 상호 운용성 보장.
> - 핵심 구성 요소: 트랜잭션 관리기(TM)와 리소스 관리자(RM).
> - 트랜잭션의 시작, 커밋, 롤백 등을 조정.

**분산 트랜잭션: TC/C (Try-Confirm/Cancel)**

- TC/C는 두 단계로 구성된 보상 트랜잭션이다.
    1. 조정자는 모든 데이터베이스에 트랜잭션에 필요한 자원 예약을 요청한다.
    2. 조정자는 모든 데이터베이스로부터 회신을 받는다.
        1. 모두 OK인 경우 조정자는 모든 데이터베이스에 작업 확인을 요청한다. (Try-Confirm)
        2. 하나라도 NO인 경우 조정자는 모든 데이터베이스에 작업 취소를 요청한다. (Try-Cancel)
- 2PC의 두 단계는 한 트랜잭션이지만 TC/C는 각 단계가 별도 트랜잭션이라는 점에 유의해야한다.

**TC/C 예제**

| 단계 | 실행연산 | 계정 A | 계정 B |
| --- | --- | --- | --- |
| 1 | 시도 | 잔액 변경: -$1 | 아무것도 하지 않음 |
| 2-1 | 확인 | 아무것도 하지 않음 | 잔액 변경: +$1 |
| 2-2 | 취소 | 잔액 변경: +$1 | 아무것도 하지 않음 |

`첫 번째 단계: 시도`

1. 조정자는 계정 A가 포함된 데이터베이스에 A의 잔액을 1달러 감소시키는 트랜잭션을 시작한다
2. 조정자는 계정 C가 포함된 데이터베이스에는 아무런 작업도 하지 않는다. 조정자는 데이터베이스에 NOP(no operation) 명령을 보낸다고 가정한다. 데이터베이스는 NOP명령에 아무 작업도 수행하지 않고 (일반적으로) 항상 성공했다는 응답을 보낸다.

`두 번째 단계: 확정`

- 두 데이터베이스 가 모두 OK면 지갑 서비스는 확정 단계를 시작한다.
- 계정 A는 첫번째 단계에서 -$1 가 되었으므로 계정 C의 잔액만 +$1 해준다.

`두 번째 단계: 취소`

- 첫번째 단계에서 계정 C에 대한 NOP 연산이 실패할 수도 있다. (계정 C가 불법계정이거나 일반적인 상황이 아닌 케이스) 그런 경우 분산 트랜잭션을 취소하고 관련된 자원을 반환해야한다.
- 첫번째 단계에서 계정 A의 잔액은 이미 바뀌었고 트랜잭션은 종료되었다. 이미 종료된 트랜잭션을 되돌리려면 조정자에서 새로운 트랜잭션을 실행하여 계정 A에 1달러를 다시 추가해야한다.
- 첫번째 단계에서 계정 C의 잔액은 업데이트하지 않았으므로 계정 C의 데이터베이스에는 NOP 명령을 전송한다.
- TC/C 장점
    - 트랜잭션을 지원하는 데이터베이스라면 종류에 상관 없이 TC/C가 작동한다.
- TC/C 단점
    - 애플리케이션 계층의 비즈니스로직에서 세부 사항을 관리하고 분산 트랜잭션의 복잡성을 처리해야한다.

**2PC와 TC/C의 비교**

|  | 첫 번째 단계 | 두 번째 단계: 성공 | 두 번째 단계: 실패 |
| --- | --- | --- | --- |
| 2PC | 로컬 트랜잭션은 아직 완료되지 않은 상태 | 모든 로컬 트랜잭션 커밋 | 모든 로컬 트랜잭션을 취소 |
| TC/C | 모든 로컬 트랜잭션이 커밋되거나 취소된 상태로 종료 | 새 로컬 트랜잭션 실행 | 이미 커밋된 트랜잭션의 실행 결과를 되돌림 |

**단계별 상태 테이블**

- 아직 풀리지 않은 문제
    - TC/C 실행 도중에 서비스가 재시작되면? 모든 작업 기록이 사라지므로 각 단계 상태 정보를 데이터베이스에 저장해야한다.
- 상태정보 시스템을 stateless로 설계할때 갖춰야할 최소 스펙
    - 분산 트랜잭션의 ID
    - 각 데이터베이스에 대한 첫번째 단계(Try) 상태
        - Not sent yet
        - Has been sent
        - Response received
    - 두번째 단계 상태
        - Confirm
        - Cancel
    - 순서가 어긋났음을 나타내는 플래그 (뒤에서 자세히)
- 단계별 상태 테이블은 돈을 인출할 지갑의 계정이 있는 데이터베이스에 동일하게 두는게 일반적으로 좋다.
- TC/C 에서 발생 가능한 이슈
    - 불균형 상태
    - 유효한 연산 순서
    - 잘못된 순서로 실행된 경우

**불균형 상태**

- 분산 트랜잭션 실행 도중에는 항상 데이터 불일치가 발생한다.
    - 계정 A와 계정 C의 잔액 총합이 1인데 첫 번째 단계만 실행된경우 계정 A와 계정 C의 잔액 총합이 0이된다.
- 이 불균형 상태가 발생할 수 있는것을 인지하고 애플리케이션 레벨에서 처리해야한다.

**유효한 연산 순서**

- 첫번째 단계에서 선택할 수 있는 일

| 선택지 | 계정 A | 계정 B |
| --- | --- | --- |
| 선택1 | -$1 | NOP |
| 선택2 | NOP | +$1 |
| 선택3 | -$1 | +$1 |
- 선택지 2
    - 계정 C의 연산(+$1)은 성공하였으나 계정 A의 연산(NOP)이 실패한경우 서비스는 취소 단계를 실행해야 한다.
    - 그러나 불일치 단계에서 누군가 C계정에서 $1를 이미 이체한다면? 이는 분산 트랜잭션의 트랜잭션 보증을 위반하게된다.
- 선택지 3
    - 선택지 2와 같은 문제 발생 가능
- 따라서 첫번째 시도 단계에서는 선택지 1만 유효하다.

**잘못된 순서로 실행된 경우**

- TC/C에는 실행 순서가 어긋날 수 있다는 문제가 있다. (네트워크 이슈 등등 .. )
- 계정 A에서 Try 연산이 실패해서 계정 A, 계정 C 모두 Cancel 명령을 수행해야하는데 네트워크문제로 계정 C에서 Try 보다 Cancel 연산을 먼저 받을 수 있다.
    - Cancel 명령이 먼저 도착하면 데이터베이스에 아직 상응하는 Try 명령을 못보았음을 나타내는 플래그를 true로 설정하여 저장해둔다.
    - Try 명령이 도착하면 항상 먼저 도착한 Cancel 명령이 있었는지 확인한다. 만약 있다면 바로 실패를 반환한다.

**분산 트랜잭션: Saga**

- Saga는 유명한 분산 트랜잭션 솔루션 가운데 하나로 마이크로서비스 아키텍처에서는 사실상 표준이다.
- 개념 설명
    1. 모든 연산은 순서대로 정렬된다. 각 연산은 자기 데이터베이스에 독립 트랜잭션으로 실행된다.
    2. 연산은 첫 번째부터 마지막까지 순서대로 실행된다. 한 연산이 완료되면 다음 연산이 개시된다.
    3. 연산이 실패하면 전체 프로세스는 실패한 연산부터 맨 처음 연산까지 역순으로 보상 트랜잭션을 통해 롤백된다. 따라서 n개의 연산을 실행하는 분산 트랜잭션은 보상 트랜잭션을 위한 n개의 연산까지 총 2n개의 연산을 준비해야 한다.
- 연산 실행순서를 조율하는 방법
    - 분산 조율 (Choreography)
        - 마이크로서비스에서 분산 트랜잭션에 관련된 모든 서비스가 다른 서비스의 이벤트를 구독하여 작업을 수행하는 방식
        - 서비스끼리 서로 비동기식으로 통신한다.
        - 모든 서비스는 다른 서비스가 발생시킨 이벤트의 결과로 어떤 작업을 수행할지 정하기 위해 내부적으로 상태기계를 유지해야한다.
        - 서비스가 많으면 관리가 어렵다.
    - 중앙 집중형 조율 (Orchestration)
        - 하나의 조정자(coordinator)가 모든 서비스가 올바른 순서로 작업을 실행하도록 조율한다.
        - 복잡한 상황을 비교적 잘 처리한다.
- 어떤식으로 조율할지는 사업상 필요와 목표에 따라 정하지만 일반적으로 Orchestration 방식을 사용한다.

**TC/C vs Saga**

|  | TC/C | Saga |
| --- | --- | --- |
| 보상 트랜잭션 실행 | 취소 단계 | 롤백 단계 |
| 중앙 조정 | OK | OK (Orchestration 방식만) |
| 작업 실행 순서 (이해안됨) | 임의 | 선형 |
| 벙렬 실행 가능성 (이해안됨) | OK | NO |
| 일시적으로 일관되지 않은 상태 허용 | OK | OK |
| 구현 계층 | 애플리케이션 | 애플리케이션 |
- 그래서 TC/C랑 Saga중 뭘 골라야하는데?
    - 지연 시간 요구사항이 없거나 서비스 수가 적다면 아무거나 사용해도 됨.
    - MSA면 일반적으로 Saga를 선택하면 됨
    - 지연시간에 민감하고 많은 서비스/운영이 관계된 시스템이라면 TC/C가 더 나음 (이해안됨)
- 아직 해결되지 않은 문제
    - 모든 계정에서 발생하는 연산을 감사할 방법은?! (재현성)

### **이벤트 소싱**

**배경**

- 외부감사에서 아래와 같은 질문들을 할 수 있다.
    - 특정 시점의 계정 잔액을 알 수 있나요?
    - 과거 및 현재 계정 잔액이 정확한지 어떻게 알 수 있나요?
    - 코드 변경 후에도 시스템 로직이 올바른지 어떻게 검증하나요?
- 이러한 질문에 체계적으로 답할 수 있는 설계 철학 중 하나는 도메인 주도 설계 (DDD) 에서 개발된 기법인 이벤트 소싱이다.

**정의**

- 이벤트 소싱의 네가지 중요한 용어
    - 명령 command
    - 이벤트 event
    - 상태 state
    - 상태 기계 state machine

`명령 command`

- 명령은 외부에서 전달된, 의도가 명확한 요청이다.
- 이벤트 소싱에서 순서는 아주 중요하기때문에 명령은 일반적으로 FIFO큐에 저장된다.

`이벤트 event`

- 명령은 의도가 명확하지만 fact가 아니기때문에 유효하지 않을 수 있고 유효하지 않은 명령은 실행할 수 없다.
- 작업 이행 전에 반드시 명령의 유효성 검사를 해야한다. 그리고 검사를 통과한 명령은 반드시 이행되어야한다.
- 명령 이행 결과를 이벤트라고한다.
- 명령과 이벤트 사이에 두 가지 차이점
    1. 이벤트는 검증된 사실로, 실행이 끝난 상태다. 그래서 이벤트에 대해 이야기할때는 과거 시제를 사용한다. 명령은 "A에서 C로 1$ 송금" 이라면 이벤트는 "A에서 C로 1$ 송금을 완료하였음" 이 된다.
    2. 명령에는 무작위성이나 IO가 포함될 수 있지만 이벤트는 결정론적이다. 이벤트는 과거에 실제로 있었던 일이다.
- 이벤트 생성 프로세스의 두가지 중요한 특성
    1. 하나의 명령으로 여러 이벤트가 만들어질 수 있다. (0이상)
    2. 이벤트 생성 과정에는 무작위성이 개입될 수 있어서, 같은 명령에 항상 동일한 이벤트들이 만들어진다는 보장이 없다. 이벤트 생성 과정에는 외부 I/O 또는 난수가 개입될 수 있다.
- 이벤트 순서는 명령 순서를 따라야하므로 이벤트도 FIFO 큐에 저장한다.

> 결정론적 의미
> 
> - **결정론적**이라는 의미는 동일한 입력이 주어졌을 때 항상 동일한 결과를 산출한다는 것을 의미합니다.
> - 이벤트 소싱에서 이벤트는 시스템의 상태 변화를 기록한 불변의 사실입니다. 이는 이벤트가 발생한 순서와 내용이 동일하다면, 시스템의 상태를 항상 동일하게 재현할 수 있음을 의미합니다.

`상태 state`

- 상태는 이벤트가 적용될 때 변경되는 내용이다.
- 지갑 시스템에서 상태는 모든 클라이언트 계정의 잔액으로 Map 자료구조를 사용하여 표현할 수 있다.

`상태 기계 state machine`

- 상태 기계는 이벤트 소싱 프로세스를 구동한다
- 상태 기계의 두가지 기능
    1. 명령의 유효성을 검사하고 이벤트를 생성한다.
    2. 이벤트를 적용하여 상태를 갱신한다.
- 이벤트 소싱을 위한 상태 기계는 무작위성을 내포할 수 없고 결정론적으로 동작해야한다.

**지갑 서비스 예시**

1. 명령 대기열에서 명령을 읽는다 (FIFO 큐. 일반적으로 카프카)
2. 데이터베이스에서 잔액 상태를 읽는다.
3. 명령의 유효성을 검사한다. 유효하면 계정별로 이벤트를 생성한다.
4. 다음 이벤트를 읽는다.
5. 데이터베이스의 잔액을 갱신하여 이벤트 적용을 마친다.

**재현성**

- 이벤트 소싱이 다른 아키텍처에 비해 갖는 가장 중요한 장점은 재현성이다.
- 데이터베이스는 특정 시점의 잔액이 얼마인지만 보여준다. 하지만 이벤트를 처음부터 다시 재생하면 과거 잔액 상태는 언제든 재구성 할 수 있다.
- 이벤트 리스트는 불변이고 상태 기계는 결정론적이므로 이벤트 이력을 재생하여 만들어낸 상태는 언제나 동일하다.
- 재현성을 갖추면 감사관이 던지는 까다로운 질문에 쉽게 답할 수 있다.
    - 특정 시점의 계정 잔액을 알 수 있나요?
    - => 시작부터 계정 잔액을 알고 싶은 시점까지 이벤트를 재생하면 알 수 있다.
    - 과거 및 현재 계정 잔액이 정확한지 어떻게 알 수 있나요?
    - => 이벤트 이력에서 계정 잔액을 다시 계산해보면 잔액이 정확한지 알 수 있다.
    - 코드 변경 후에도 시스템 로직이 올바른지 어떻게 검증하나요?
    - => 새로운 코드에 동일한 이벤트 이력을 입력으로 주고 같은 결과가 나오는지 보면 된다.
- 감사 가능 시스템이어야 한다는 요건이 있으면 이벤트 소싱이 채택되는 경우가 많다.

**명령-질의 책임 분리(CQRS)**

- 이벤트소싱에서 데이터를 효과적으로 제공하는 방법 => CQRS 사용하기
    - 상태 이력 데이터베이스의 읽기 전용 사본을 생성한 다음 외부와 공유하게한다.
    - 이벤트 소싱은 상태를 직접 공개하지 않고 모든 이벤트를 외부에 보낸다.
    - 이벤트를 수신하는 모든 외부 주체는 직접 상태를 재구축할 수 있다.
- CQRS에서는 상태 기록을 담당하는 상태 기계는 하나고 읽기 전용 상태 기계는 여러 개 있을 수 있다.
- 읽기 전용 상태 기계의 활용
    - 클라이언트의 잔액 질의 요청을 처리하기 위해 별도 데이터베이스에 상태를 기록
    - 이중 청구 등의 문제를 쉽게 조사할 수 있도록 하기 위해 특정한 기간 동안의 상태를 복원
    - 재무기록과 감사기록용도로 상태 기록

## **3단계: 상세 설계**

**고성능 이벤트 소싱**

`파일 기반의 명령 및 이벤트 목록`

- 명령과 이벤트를 카프카 같은 원격 저장소가 아닌 로컬 디스크에 저장하는 방안을 생각해볼 수 있다.
- 이 방법의 장점
    - 네트워크를 안쓰기때문에 전송 시간을 아낄 수 있다.
    - 이벤트는 추가 만 가능한 자료구조에 저장한다. 순차쓰기를 사용하면 매우 빠르게 읽기 및 쓰기 연산이 가능하다. 운영체제는 보통 순차 읽기, 쓰기 작업에 매우 특화되어 있다.
- 최근 명령과 이벤트를 메모리에 캐시하는 방안도 생각해볼 수 있다. => mmap 사용하기
    - mmap을 사용하면 로컬 디스크에 쓰는 동시에 최근 데이터는 메모리에 자동으로 캐시할 수 있다.

`파일 기반 상태`

- 상태 정보도 RDB같은 저장소가 아닌 SQLite, RocksDB와 같은 로컬 전용 DB에 저장할 수 있다.
- RocksDB는 쓰기 작업에 최적화된 자료구조 LSM(Log-Structured Merge-tree)를 사용한다.

> LSM
> 
> - LSM-tree는 데이터베이스에서 쓰기 성능을 최적화하기 위해 설계된 데이터 구조다.
> - 데이터가 디스크에 순차적으로 기록되도록 설계되어 있다.

`스냅숏`

- 재현성 확보를 위해 상태 기계로 하여금 이벤트를 항상 처음부터 다시 읽었다.
- 그 대신 주기적으로 현재 상태를 파일에 저장하고 스냅샷을 본다면 시간을 절약할 수 있다.
- 스냅샷은 과거 특정 시점의 상태로, 불변이다.
- 특정 시점의 스냅샷을 찍었다면, 해당 스냅샷을 읽고, 어느 시점에 만들어졌는지 확인한 다음, 그 시점부터 이벤트 처리를 시작하면 된다.
- 지갑 서비스 같은 금융 애플리케이션은 자정에 스냅숏을 찍는 일이 많다.
- 스냅샷은 거대한 binary 파일이며, 일반적으로 HDFS과 같은 객체 저장소에 저장한다.
- 성능 자체로만 보면 파일 기반 솔루션이 좋을 수 있으나 무상태 서비스가 아니고, SPOF 가 될 수 있다.

**신뢰할 수 있는 고성능 이벤트 소싱**

`신뢰성 분석`

- 데이터의 내구성이 보장되는 한, 최종 결과는 이벤트를 다른 노드에서 돌려서 복구할 수 있다. 즉, 데이터의 안정성(신뢰성)이 훨씬 중요하다.
- 지금 설계하고 있는 시스템의 네가지 유형 데이터
    - 파일 기반 명령
    - 파일 기반 이벤트
    - 파일 기반 상태
    - 상태 스냅숏
- 상태와 스냅숏은 이벤트 목록을 재생하면 언제든 다시 만들 수 있다.
- 이벤트는 명령에서 만들어지니 명령의 신뢰성만 강력하게 보장하면 충분하게 생각할 수 있는데, 이벤트 생성이 결정론적 과정이 아니며, 난수나 외부 입출력 등의 무작위적 요소가 포함될 수 있다. 따라서 명령의 신뢰성 만으로는 이벤트의 재현성을 보장할 수 없다.
- 이벤트는 상태에 변화를 가져오는 과거의 사실이다. 이벤트는 불변이며 상태 재구성에 사용할 수 있다. 따라서 신뢰성을 보장할 유일한 데이터는 이벤트다.

`합의`

- 높은 안정성을 제공하려면 이벤트 목록을 여러 노드에 복제해야 한다.
- 복제 과정에서 보장해야할 두가지 요소
    1. 데이터(이벤트) 손실 없음
    2. 로그 파일 내 데이터의 상대적 순서는 모든 노드에 동일
- 래프트 알고리즘
    - 래프트 알고리즘을 사용하면 노드의 절반 이상이 live 상태일때 모든 노드에 보관된 append only 리스트는 같은 데이터를 가진다.
    - 예를 들어 다섯 노드가 있을 때 래프트 알고리즘을 사용하여 데이터를 동기화하면 최소 3개 노드만 동작해도 서비스는 정상 동작한다.
    - 래프트 알고리즘을 사용하면 과반수 노드가 작동하는 한 시스템은 안정적이다.

> 래프트 알고리즘 주요 구성 요소
> 
> 1. **리더 선출**: 노드들 중 하나를 리더로 선출합니다. 리더는 클라이언트의 요청을 처리하고 로그 복제를 관리합니다.
> 2. **로그 복제**: 리더는 클라이언트의 요청을 로그로 기록하고, 이 로그를 다른 팔로워 노드들에게 복제하여 데이터 일관성을 유지합니다.
> 3. **합의 과정**: 로그 항목이 과반수의 노드에 복제되면 커밋되며, 이 상태는 클라이언트에게 응답됩니다.
> 4. **안전성**: 리더가 교체되더라도 이전에 커밋된 로그 항목은 유지되며, 시스템은 일관성을 잃지 않습니다.

`고신뢰성 솔루션`

- 복제 메커니즘을 활용하면 파일 기반 이벤트 소싱 아키텍처에서 SPOF를 없앨 수 있다
- 이 노드들은 래프트 알고리즘을 사용하여 이벤트 목록을 안정적으로 동기화한다
    - 리더는 외부 사용자로부터 들어오는 명령 요청을 받아 이벤트로 변환하고 로컬 이벤트 목록에 추가한다. 새로운 이벤트는 모든 팔로어에 복제한다.
    - 팔로워, 리더는 이벤트 목록을 처리하고 상태를 업데이트한다.
    - 래프트 알고리즘은 리더와 팔로워가 동일한 이벤트 목록을 갖도록하며, 동일한 상태가 만들어지도록 한다.
- 래프트 알고리즘의 장애처리
    - 리더에 장애가 발생하면 래프트 알고리즘은 나머지 정상 노드 중에서 새 리더를 선출한다.
    - 새 리더는 외부 사용자로부터 오는 명령을 수신할 책임을 진다.
    - 유의할 것은 리더 장애가 명령 목록이 이벤트로 변환되기 전에 발생할 수 있다. 그런 일이 생기면 클라이언트단에서 오류응답을 던진다.
    - 팔로워에 장애가생기면 해당 팔로워로 전송된 요청은 실패하지만 서비스에 영향은 없다. 새로운 노드로 대체될때까지 재시도하여 팔로워를 복구한다.

**분산 이벤트 소싱**

- 고신뢰성 솔루션을 사용한다고하더라도 풀지 못하는 문제
    1. 사용자가 업데이트 결과를 즉시 받고싶어한다면? CQRS 시스템에서는 요청/응답 흐름이 느릴 수 있다. 클라이언트가 데이터의 업데이트 시점을 정확하게 알 수 없어서 주기적 폴링에 의존할 수 밖에 없기 때문이다.
    2. 단일 래프트 그룹의 용량은 제한되어 있다. 일정 규모 이상에서는 데이터를 샤딩하고 분산 트랜잭션을 구현해야한다.

`풀 VS 푸싱`

- 풀 모델에서는 외부 사용자가 읽기 전용 상태 기계에서 주기적으로 실행 상태를 읽는다. 만약 읽는 주기가 너무 짧다면 서비스에 과부하가 걸릴 수도 있다.
- reverse proxy
    - 풀 모델은 외부 사용자와 이벤트 소싱 노드 사이에 reverse proxy를 추가해서 개선할 수 있다.
    - 외부 사용자는 reverse proxy에 명령을 보내고 reverse proxy는 명령을 이벤트 소싱 노드로 전달하고 주기적으로 실행 상태를 질의한다.
    - 이렇게 하더라도 주기적 폴링으로 폴링하는것은 동일하지만 클라이언트 코드가 단순해진다.
- reverse proxy를 두면 읽기 전용 상태 기계를 수정해서 응답 속도를 높일 수 있다.
- 읽기 전용 상태 기계로 하여금 이벤트를 수신하자마자 실행 상태를 reverse proxy에 푸시하면 사용자 입장에서는 응답이 실시간으로 되는것처럼 구현할 수 있다

`분산 트랜잭션`

- 모든 이벤트 소싱 노드 그룹이 동기적 실행 모델을 채택하면 TC/C나 Saga같은 분산 트랜잭션 솔루션을 재사용할 수 있다.
- 최종 설계안

1. 사용자 A가 Saga 조정자에게 분산 트랜잭션을 보낸다. 두개의 연산이 들어 있다. A: -$1, C: +$1
2. Saga 조정자는 단계별 상태 테이블에 레코드를 생성하여 트랜잭션 상태를 추적한다.
3. Saga 조정자는 작업 순서를 검토한 후 A: -$1를 먼저 처리하기로 결정한다. 조정자는 A: -$1의 명령을 계정 A정보가 있는 파티션 1로 보낸다.
4. 파티션1의 래프트 리더는 A: -$1 명령을 수신하고 명령 목록에 저장한다. 그 다음 명령의 유효성을 검사한다. 유효하면 이벤트로 변환한다. 래프트 알고리즘으로 모든 팔로워에게 이벤트를 동기화한다.
5. 이벤트가 동기화되면 파티션1의 이벤트 소싱 프레임워크가 CQRS를 사용하여 데이터를 읽기 경로로 동기화한다.
6. 파티션 1의 읽기 경로는 이벤트 소싱 프레임워크를 호출한 Saga 조정자에게 상태를 푸시한다.
7. Saga 조정자는 파티션1에서 성공 상태를 수신한다.
8. Saga 조정자는 단계별 상태 테이블에 파티션1의 작업이 성공했음을 나타내는 레코드를 생성한다.
9. 첫 번째 작업이 성공했으므로 Saga 조정자는 두번째 작업인 C: +$1를 실행한다. 조정자는 계정 C의 정보가 포함된 파티션2에 C: +$1 명령을 보낸다.
10. 파티션2의 래프트 리더는 C: +$1 명령을 수신하고 명령 목록에 저장한다. 그 다음 명령의 유효성을 검사한다. 유효하면 이벤트로 변환한다. 래프트 알고리즘으로 모든 팔로워에게 이벤트를 동기화한다.
11. 이벤트가 동기화되면 파티션2의 이벤트 소싱 프레임워크가 CQRS를 사용하여 데이터를 읽기 경로로 동기화한다.
12. 파티션 2의 읽기 경로는 이벤트 소싱 프레임워크를 호출한 Saga 조정자에게 상태를 푸시한다.
13. Saga 조정자는 파티션2에서 성공 상태를 수신한다.
14. Saga 조정자는 단계별 상태 테이블에 파티션2의 작업이 성공했음을 나타내는 레코드를 생성한다.
15. 모든 작업이 성공했으므로 분산 트랜잭션이 완료된다. Saga 조정자는 호출자에게 결과를 응답한다.

## **4단계: 마무리**

- TPS 추정, 데이터베이스 노드 수 추정
- 레디스 사용하기 <= 트랜잭션 사용 불가
- RDB사용하기 <= 트랜잭션 사용 가능
- 분산 트랜잭션
    - 2PC
    - TC/C
    - Saga
- 이벤트 소싱(재현성)
- 래프트 알고리즘
- 이벤트 소싱 + CQRS