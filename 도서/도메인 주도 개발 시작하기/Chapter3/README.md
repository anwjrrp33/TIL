# 애그리거트

## 애그리거트
* 상위 수준 개념을 이용해서 전체 모델을 정리하면 전반적인 관계를 이해하는데 도움이 된다.
<br/><img src="./그림 3.1.png">
* 상위 모델에 대한 이해없이 상위 수준에서 개념을 파악할려면 오래 걸리며 많은코드를 보고 도메인 전문가와 더 많은 대화를 나눠야 비로소 상위 수준 모델 간의 관계가 이해되기 시작한다.
    * 도메인 객체 모델이 복잡하면 개별 구성요소 위주로 모델을 이해하게 되고 전반적인 구조나 큰 수준에서 도메인 간의 관계를 파악하기 어려워진다.
    * 코드를 변경하고 확장하는 것이 어려워진다는 것을 의미한다.
    * 당장 돌아가는 코드를 추가할 수는 있지만 이런 방법은 장기적으로 코드를 더 수정하기 어렵게 만든다.
<br/><img src="./그림 3.2.png">
* 복잡한 도메인을 이해하고 관리하기 쉬운 단위로 만들려면 상위 수준에서 모델을 조망할 수 있는 방법이 필요한데 그 방법이 `애그리거트`다.
    * 모델을 이해하는데 도움을 주며 일관성을 관리하는 기준이 된다.
    * 복잡한 도메인을 단순한 구조로 만들어주고 도메인 기능을 확장하고 변경하는데 필요한 노력(개발시간)도 줄어든다.
* 애그리거트의 경계를 설정할 때 기본이 되는 것은 도메인 규칙과 요구사항이다.
    * 도메인 규칙에 따라 함께 생성되는 구성요소는 한 애그리거트에 속할 가능성이 높다.
    * `A가 B를 갖는다` 라는 요구사항이 존재해도 한 애그리거트는 아니며 상품과 리뷰는 함께 생성되지도, 변경되지도 않기 때문에 한 애그리거트에 속하지 않는다.
* 처음 도메인 모델을 만들면 큰 애그리거트로 보이는 것들이 많지만 도메인에 대한 경험이 생기고 도메인 규칙을 제대로 이해할수록 애그리거트 실제 크기는 줄어든다.
    * 다수의 애그리거트가 한 개의 엔티티만 갖는 경우가 많고 두개 이상의 엔티티로 구성되는 애그리거트는 드물다.

## 애그리거트 루트
* 애그리거트는 여러객체를 구성되기 때문에 한 객체만 상태가 정상이면 안되며 도메인 규칙을 지키려면 애그리거트에 속한 모든 객체가 정상 상태를 가져야한다.
    * 주문이라는 애그리거트가 존재하면 OrderLine이 변경되면 Order의 totlaAmounts도 다시 계산해서 총 금액이 맞아야 한다.
* 애그리거트에 속한 모든 객체가 일관된 상태를 유지하려면 애그리거트 전체를 관리할 주체가 필요한데 이 책을 지는 것이 바로 애그리거트의 `루트 엔티티`다.
    * 애그리거트에 속한 객체는 애그리거트 루트 엔티티에 직접 또는 간접적으로 속하게 된다.

### 도메인 규칙과 일관성
* 애그리거트 루트가 단순히 애그리거트에 속한 객체를 포함하는 것으로 끝나는 것은 아니며 애그리거트 루트의 핵심 역할은 애그리거트의 일관성이 깨지지 않도록 하는 것이다.
    * 애그리거트 루트는 애그리거트가 제공해야 할 도메인 기능을 구현한다.
    * 애그리거트가 배송지 변경, 상품 변경과 같은 기능을 제공하고 애그리거트 루트인 Order가 이 기능을 구현한 메서드를 제공해준다.
* 애그리거트 루트가 제공하는 메서드는 도메인 규칙에 따라 애그리거트에 속한 객체의 일관성이 꺠지지 않도록 구현해야 한다.
    * 배송이 시작되기 전까지만 배송지 정보를 변경할 수 있다는 규칙이 있다면 루트인 Order의 changeShippingInfo() 메서드는 이 규칙에 따라 배송 시작 여부를 확인하고 규칙을 충족할 때만 배송지 정보를 변경해야한다.
* 애그리거트 외부에서 애그리거트에 속한 객체를 직접 변경하면 안된다.
    * 애그리거트 루트가 강제하는 규칙을 적용할 수 없어 모델의 일관성을 꺠는 원인이 된다.
* 불필요한 중복을 피하고 애그리거트 루트를 통해서만 도메인 로직을 구현하게 만들려면 도메인 모델에 대해서 두 가지를 습관적으로 적용해야한다.
    * 단순히 필드를 변경하는 set 메서드를 공개(public) 범위로 만들지 않는다.
        * 공개 set메서드로 인해서 도메인의 의미나 의도를 표현하지 못하고 도메인 로직을 도메인 객체가 아닌 응용 영역이나 표현 영역으로 분산시켜서 로직이 한 곳에 응집되지 않아서 코드를 유지 보수할 때에도 분석하고 수정하는데 많은 시간이 필요하다.
    * 밸류 타입은 불변으로 구현한다.
        * 밸류 타입을 불변이면 값을 변경할 수 없고 외부에서 밸류 객체의 상태를 변경할 수 없어서 일관성이 깨질 가능성이 줄어든다. 변경하는 방법은 새로운 밸류 객체를 애그리거트 루트가 제공하는 메서드를 통해서 값을 변경해야한다.

### 애그리거트 루트의 기능 구현
* 애그리거트 루트는 애그리거트 내부의 다른 객체를 조합해서 기능을 완성한다.
    * Order은 총금액을 구하기 위해서 OrderLine 목록을 사용한다.
    * Member는 암호 변경을 위해서 Password 객체에 암호가 일치하는지 확인한다.
* 애그리거트 루트가 구성요소의 상태만 참조하는 것은 아니며 기능 실행을 위임한다.
    * Order의 changeOrderLines() 메서드는 orderLines 필드에 상태 변경을 위임하는 방식으로 구현하는데 get을 제공하게 되면 외부에서 기능을 실행할 수 있게되므로 버그를 만든다. 이런 버그가 생기지 않도록 외부에서 OrderLine 목록이 변경할 수 없도록 OrderLines를 불변으로 구현한다.
    * 불변으로 구현이 불가능하다면 패키지나 protected 범위로 한정해서 실행을 제한한다.

### 트랙잭션 범위
* 트랜잭션의 범위는 작으면 작을수록 좋다.
    * 한 트랙잭션이 한 개의 테이블을 수정하는 것과 세 개의 테이블을 수정하는 것을 비교하면 성능에서 차이가 발생한다.
    * 잠금 대상이 많아진다는 것은 동시에 처리할 수 있는 트랜잭션 개수가 줄어든다는 것을 의미하고 전체적인 성능(처리량)을 떨어뜨린다.
* 한 트랙잭션에선 한 애그리거트만 수정해야한다.
    * 애그리거트 냉부에서 다른 애그리거트의 상태를 변경하는 기능을 실행하면 안된다.
    * 애그리거트는 최대한 서로 독립적이여야하고 한 애그리거트가 다른 애그리거트의 기능에 의존하면 결합도가 높아져 향후 수정 비용이 증가한다.
    * 부득이하게 한 트랜잭션으로 두 개 이상의 애그리거트를 수정해야한다면 다른 애그리거트를 직접 수정하지말고 응용 서비스에서 두 애그리거트를 수정하도록 구현한다.
* 도메인 이벤트를 사용하면 한 트랙잭션에서 한 개의 애그리거트를 수정하면서도 동기나 비동기로 다른 애그리거트의 상태를 변경하는 코드를 작성할 수 있다.
* 한 트랙잭션에서 한 개의 애그리거트를 변경하는 것을 권장하지만 예외의 경우엔 두개 이상의 애그리거트를 변경하는 것을 고려할 수 있다.
    * 팀 표준: 팀이나 조직의 표준에 따라 사용자 유스케이스와 관련된 응용 서비스의 기능을 한 트랜잭션으로 실행해야 하는 경우가 있다.
    * 기술 제약: 기술적으로 이벤트 방식을 도입할 수 없는 경우 한 트랜잭션에서 다수의 애그리거트를 수정해서 일관성을 처리해야 한다.
    * UI 구현의 편리: 운영자의 편리함을 위해 주문 목록 화면에서 여러 주문의 상태를 한 번에 변경하고 싶을 것이다. 이 경우 한 트랜잭션에서 여러 주문 애그리거트의 상태를 변경해야 한다.

## 리포지터리와 애그리거트
