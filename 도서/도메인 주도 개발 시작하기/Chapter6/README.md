# 6 응용 서비스와 표현 영역

## 6.1 표현 영역과 응용 영역
* 도메인 영역을 잘 구현하지 않으면 사용자의 요구를 충족하는 제대로 된 소프트웨어를 만들지 못한다. 하지만 도메인 영역만 잘 만든다고 끝나는 것은 아니다.
* 도메인이 제 기능을 하려면 사용자와 도메인을 연결 해주는 매개체가 필요하고 응용 영역과 표현 영역이 사용자와 도메인을 연결해 주는 매개체 역할을 한다.

<img src="./그림 6.1.png">

* 표현 영역은 사용자의 요청을 해석하고 사용자가 실행하고 싶은 기능을 판별하고 그 기능을 제공하는 응용 서비스를 실행한다.
* 실제 사용자가 원하는 기능을 제공하는 것은 응용 영역에 위치한 서비스이며 응용 서비스는 기능을 실행하는데 필요한 입력 값을 메서드 인자로 받고 실행 결과를 리턴한다.
* 사용자와 상호작용은 표현 영역이 처리하기 때문에 응용 서비스는 표현 영역에 의존하지 않는다.

## 6.2 응용 서비스의 역할
* 응용 서비스는 사용자가 요청한 기능을 실행한다.
* 응용 서비스의 주요 역할로는 도메인 객체를 사용해서 사용자의 요청을 처리하고 도메인 영역과 표현 영역을 연결해 주는 창구 역할을 한다.
* 주로 도메인 객체 간의 흐름을 제어하기 때문에 단순한 형태를 갖는다.
```
public Result doSomeFunc(SomeReq req) {
    // 1. 리포지터리에서 애그리거트를 구한다.
    SomeAgg agg = someAggRepository.findById(req.getId()); 
    checkNull(agg);
    
    // 2. 애그리거트의 도메인 기능을 실행한다. 
    agg.doFunc(req.getValue());

    // 3. 결과를 리턴한다.
    return createSuccessResult(agg);
}
```
* 응용 서비스가 복잡하다면 응용 서비스에서 도메인 로직의 일부를 구현하고 있을 가능성이 높다.
* 응용 서비스가 도메인 로직을 일부 구현하면 코드 중복, 로직 분산 등 코드 품질에 안 좋은 영향을 줄 수 있다.
* 응용 서비스는 트랜잭션 처리도 담당한다.
* 응용 서비스는 데이터 일관성을 지키기 위해서 도메인 상태 변경을 트랜잭션으로 처리해야 한다.
* 응용 서비스의 주요 역할로는 트랜잭션 외에도 접근 제어와 이벤트 처리가 있다.

### 6.2.1 도메인 로직 넣지 않기
* 도메인 로직을 도메인 영역과 응용 서비스에 분산해서 구현하면 코드 품질에 문제가 발생한다.
    * 코드의 응집성이 떨어진다.
    * 동일한 도메인 로직을 구현할 가능성이 높아져서 코드의 중복이 발생한다.
* 도메인 로직이 응용 서비스에 출현하면 응집도가 떨어지고 코드의 중복 발생으로 결과적으로 코드 변경을 어렵게 만든다.
* 소프트웨어가 가져야 하는 중요한 경쟁요소는 변경 용이성인데 변경이 어렵다는 것은 그만큼 소프트웨어의 가치가 떨어진 다는것을 의미한다.
* 소프트웨어의 가치를 높이려면 도메인 로직을 도메인 영역에 모아서 코드 중복을 높이고 응집도를 높여야 한다.

## 6.3 응용 서비스의 구현
* 응용 서비스는 표현 영역과 도메인 영역을 연결하는 매개체 역할을 하는데 이는 디자인 패턴에서 `파사드`와 같은 역할을 한다.

### 6.3.1 응용 서비스의 크기
* 응용 서비스의 구현 자체는 어렵지 않지만 생각할 거리가 존재하는데 그 중 하나가 응용 서비스의 크기이다.
* 회원 도메인을 생각해봤을 때 응용 서비스는 보통 두 가지 방법 중 한 가지 방식으로 구현한다.
    * 한 응용 서비스 클래스에 회원 도메인의 모든 기능 구현하기
        * 한 도메인과 관련된 기능을 구현한 코드가 한 클래스에 위치하므로 각 기능에서 동일한 로직에 대한 코드 중복을 제거할 수 있다는 장점이 있다.
        * 모든 기능이 한 서비스 클래스에 모여서 크기(코드 줄 수)가 커지게 되는데 코드 크기가 커지면 연관성이 적은 코드가 한 클래스에 함께 위치할 가능성이 높아지고 관련 없는 코드가 뒤섞여 코드 이해를 방해한다는 단점이 있다.
    * 구분되는 기능별로 응용 서비스 클래스를 따로 구현하기 (저자의 선호 방식)
        * 구분되는 기능별로 구현하는 방식은 한 응용 서비스 클래스에 2~3개의 기능을 구현한다.
        * 클래스의 개수는 많아지지만 한 클래스에 관련 기능을 모두 구현하는 것과 비교해서 코드 품질을 일정 수준으로 유지하는데 도움이 된다.
        * 각 클래스별로 필요한 의존 객체만 포함하므로 다른 기능을 구현할 코드에 영향을 받지 않는다.
        * 각 기능마다 동일한 로직을 구현할 경우 여러 클래스에 중복된 코드를 구현할 가능성이 높아진다. 하지만 별로 클래스에 로직을 구현해서 코드가 중복되는 것을 방지할 수 있다.

### 6.3.2 응용 서비스의 인터페이스와 클래스
* 응용 서비스를 구현할 때 논쟁이 될 만한 것이 인터페이스가 필요한 지이다.
    * 구현 클래스가 다수 존재하거나 런타임에 구현 객체를 교체해야 할 경우
    * 표현 영역에서 단위 테스트를 위해 응용 서비스 클래스의 가짜 객체가 필요한 경우 (Mockito를 사용하면 필요X)
* 응용 서비스는 런타임에 교체하는 경우가 거의 없고 한 응용 서비스의 구현 클래스가 두 개인 경우도 드물다. 이런 이유로 인터페이스와 클래스를 따로 구현하면 소스 파일만 많아지고 구현 클래스에 대한 간접 참조가 증가해서 전체 구조가 복잡해진다.
* 인터페이스가 명확히 필요하기 전까지 인터페이스를 추가하는것은 좋은 선택이라고 볼 수는 없다.
* TDD를 즐겨하고 표현 영역부터 개발을 시작한다면 미리 응용 서비스를 구현할 수 없어서 인터페이스를 추가할 수 있다.
```
// 인터페이스를 만들고 이를 상속한 클래스를 만드는 것이 필요할까?
public interface ChangePasswordService {
    public void changePassword(String memberId, String curPw, String newPw);
}

public class ChangePasswordServicelmpl implements ChangePasswordService {
    ...구현 
}
```

### 6.3.3 메서드 파라미터와 값 리턴
* 응용 서비스가 제공하는 메서드는 도메인을 이용해서 사용자가 요구한 기능을 실행하는데 필요한 값을 파라미터로 전달 받아야 한다.
* 파라미터는 각 값을 개별로 전달 받을 수도 별도 데이터 클래스(DTO)를 만들어서 전달 받을 수 있다.
* 클래스에 대한 변환은 스프링 MVC와 같은 프레임워크의 객체 변환 기능을 이용하면 된다.
* 응용 서비스 결과를 표현 영역에서 사용해야 한다면 필요한 데이터를 리턴하면 된다. 대표적인 예가 식별자 이다.
* 애그리거트 객체를 그대로 리턴할 수도 있다. 이 경우 코딩은 편하지만 도메인 로직이 표현 영역에서도 실행할수 있게되므로 응집도를 낮추는 원인이 된다.
* 애그리거트를 리턴해도 애그리거트가 제공하는 기능을 컨트롤러나 뷰에서 실행하면 안된다는 규칙을 정할 수도 있지만 그보단 필요한 데이터만 리턴하는 것이 실행 로직의 응집도를 높이는 확실한 방법이다.

### 6.3.4 표현 영역에 의존하지 않기
* 응용 서비스의 파라미터 타입을 결정할 때 주의할 점은 표현 영역과 관련된 타입을 사용하면 안 된다는 점이다.
```
// 응용 서비스가 표현 영역을 의존하는 코드 예시
@Controller 
@RequestMapping("/member/changePassword") 
public class MemberPasswordController {
    @PostMapping
    public String submit(HttpServletRequest request) {
        try {
            // 응용 서비스가 표현 영역을 의존하면 안 됨!
            // HttpServletRequest나 HttpSession을 응용 서비스에 파라미터로 전달하면 안 됨
            changePasswordService.changePassword(request); 
        } catch(NoMemberException ex) {
            // 알맞은 익셉션 처리 및 응답
        } 
    }
}
```
* 응용 서비스에서 표현 영역에 대한 의존이 발생하면 응용 서비스만 단독으로 테스트하기 어려워지며 표현 영역의 구현이 변경되면 응용 서비스의 구현도 함께 변경해야 하는 문제가 발생한다.
* 심각한 점은 응용 서비스가 표현 영역의 역할까지 대신하는 상황이 벌어질 수도 있다.
* 표현 영역에 의존을 하지 않는 가장 쉬운 방법은 서비스 메서드의 파라미터와 리턴 타입으로 표현 영역의 구현 기술을 사용하지 않는 것이다.

### 6.3.5 트랜잭션 처리
* 트랜잭션과 관련된 문제로 트랙잭션을 관리하는 것은 응용 서비스의 중요한 역할이다.
* 스프링과 같은 프레임워크가 제공하는 트랜잭션 관리 기능을 이용하면 쉽게 트랜잭션을 처리 할 수 있다.
```
public class ChangePasswordService {
    // 스프링의 경우 @Transactional을 사용해서 처리
    @Transactional
    public void changePassword(ChangePasswordRequest req) {
        Member member = findExistingMember(req.getMemberld());
        member.changePassword(req.getCurrentPassword(), req.getNewPassword()); 
    }
    ...
}
```

## 6.4 표현 영역
* 표현 영역의 책임은 크게 다음과 같다.
    * 사용자가 시스템을 사용할 수 있는 흐름(화면)을 제공하고 제어한다.
    * 사용자의 요청을 알맞는 응용 서비스에 전달하고 결과를 사용자에게 제공한다.
    * 사용자의 세션을 관리한다.

## 6.5 값 검증
* 값 검증은 표현 영역과 응용 서비스 두 곳에서 모두 수행할 수 있다.
* 원칙적으로 모든 값에 대한 검증은 응용 서비스에서 처리한다.
* 응용 서비스에서 각 값이 유효한지 확인할 목적으로 익셉션을 사용할 때의 문제점은 사용자 에게 좋지 않은 경험을 제공한다는 것이다.
* 값을 검사하는 시점에 첫 번째 값이 올바르지 않아 익셉션이 발생되면 나머지 항목에 대해서는 값을 검사하지 않게되서 사용자가 같은 폼에 값을 여러 번 입력하게 만든다.
* 사용자 불편 해소를 위해서 응용 서비스에서 에러 코드를 모아 하나의 익셉션으로 발생 시키는 방법이 있다.
* 스프링의 Validator 인터페이스를 별도로 제공하므로 이 인터페이스를 구현한 검증기를 따로 구현해서 사용하면 코드를 간결하게 줄일 수 있다.
* 응용 서비스를 사용하는 표현 영역 코드가 한 곳이면 구현의 편리함을
위해 다음과 같이 역할을 나누어 검증을 수행할 수도 있다.
    * 표현 영역: 필수 값, 값의 형식, 범위 등을 검증한다.
    * 응용 서비스: 데이터의 존재 유무와 같은 논리적 오류를 검증한다.
* 응용 서비스에서 얼마나 엄격하게 값을 검증해야 하는지에 대해서는 의견이 갈릴 수 있는데 저자의 경우 예전엔 나눠서 검증했지만 최근엔 응용 서비스에서 필수 값과 논리적인 검증을 모두 하는 편이라고 한다.
* 응용 서비스에서 필요한 값 검증을 모두 처리하면 프레임워크가 제공하는 검증 기능을 사용할 때보다 작성한 코드가 늘어나는 불편함이 있지만 `응용 서비스의 완성도가 높아지는 이점`이 있다.

## 6.6 권한 검사
* 권한 검사는 `사용자 U가 기능 F를 실행할 수 있는지` 확인하는 것이다.
* 개발하는 시스템마다 권한의 복잡도가 다른데 다양한 상황을 충족하기 위해 `스프링 시큐리티`같은 프레임워크는 유연하고 확장 가능한 구조를 갖고 있는데 유연한 만큼 복잡하다는 것을 의미한다.
* 보안 프레임워크에 대한 이해가 부족하면 무턱대고 도입하는 것보다 시스템에 맞는 권한 검사 기능을 구현하는 것이 시스템 유지 보수에 유리할 수 있다.
* 보안 프레임워크는 보통 다음 세 곳에서 권한 검사를 수행할 수 있다.
    * 표현 영역
        * 표현 영역에서 할수 있는 기본적인 검사는 인증된 사용자인지 아닌지 검사하는 것이다.
        * URL은 인증된 사용자만 접근해야 하는데 이런 접근 제어를 하기에 좋은 위치가 `서블릿 필터`다.
        <img src="./그림 6.3.png">
        * 인증 여부뿐만 아니라 권한에 대해서 동일한 방식으로 필터를 사용해서 URL별 권한 검사를 할 수 있고, 유사한 방식으로 필터를 이용해서 인증 정보를 생성하고 웹 접근을 제어한다.
    * 응용 서비스
        * URL 만으로 접근 제어를 할 수 없는 경우엔 응용 서비스 메서드 단위로 권한 검사를 수행해야 한다.
        * 스프링 시큐리티는 AOP를 활용해서 애너테이션으로 서비스 메서드에 대한 권한 검사 기능을 제공한다.
            ```
            public class BlockMemberService {
                private MemberRepository memberRepository;
                // @PreAuthorize 애너테이션을 통한 권한 검사
                @PreAuthorize("hasRole('ADMIN')")
                public void block(String memberld) {
                    Member member = memberRepository.findById(memberId);
                    if (member == null) throw new NoMemberException();
                    member.block();
                }
                ```
            }
    * 도메인
        * 도메인 단위로 권한 검사를 해야 하는 경우는 다소 구현이 복잡해진다.
        * 예를 들어, 게시글 삭제는 본인 또는 관리자 역할을 가진 사용자만 할 수 있다고 해보자. 이 경우 게시글 작성자가 본인인지 확인하려면 게시글 애그리거트를 먼저 로딩해야한다.즉, 응용 서비스의 메서드 수준에서 권한 검사를 할 수 없기 때문에 직접 권한 검사 로직을 구현해야 한다.
            ```
            public class DeleteArticleService {
                public void delete(String userid, Long articleld) {
                    Article article = articleRepository.findByld(articleId);
                    checkArticleExistence(article);
                    permissionService..checkDeletePermission(userId, article);
                    article.markDeleted();
                }
                ...
            }
            ```
        * 스프링 시큐리티와 같은 보안 프레임워크를 확장해서 개별 도메인 객체 수준의 권한 검사 기능을 프레임워크에 통합할 수도 있다. 하지만 이는 프레임워크에 대한 높은 이해가 필요하다. 이해도가 높지않아 확장이 원하는 수준으로 안된다면 도메인에 맞는 권한 검사 기능을 직접 구현하는것이 코드 유지 보수에 유리하다.

## 6.7 조회 전용 기능과 응용 서비스
* 조회 전용 모델과 DAO를 서비스에서 조회 전용 기능을 사용하게 되면 서비스 코드가 단순히 조회 전용 기능을 호출하는 것으로 끝날 수 있다.
```
public class OrderListService {
    public List<OrderView> getOrderList(String ordererId) {
        return orderViewDao.selectByOrderer(ordererId);
    }
}
```
* 서비스에서 추가적인 로직도 없고 조회 전용 기능이라 트랜잭션도 필요하지 않다.
* 이런 경우엔 굳이 서비스를 만들 필요 없이 표현 영역에서 바로 조회 전용 기능을 사용해도 문제가 없다.
* 응용 서비스를 항상 만들었던 개발자는 컨트롤러와 같은 표현 영역에서 응용 서비스 없이 조회 전용 기능에 접근하는 것이 이상하게 느껴질 수 있다. 하지만 응용 서비스가 요청 기능을 실행하는 데 별다른 기여를 하지 못한다면 굳이 서비스를 만들지 않아도 된다.

<img src="./그림 6.4.png">