# 9 도메인 모델과 바운디드 컨텍스트

## 9.1 도메인 모델과 경계
처음 도메인을 만들 때 빠지기 쉬운 함정이 도메인을 완벽하게 표현하는 단일 모델을 만드는 시도를 하는 것이다.<br>
한 개의 모델로 여러 하위 도메인을 모두 표현하려고 시도하면 오히려 모든 하위 도메인에 맞지 않는 모델을 만들게 된다.

논리적으로 같은 존재처럼 보이지만 하위 도메인에 따라 다른 용어를 사용하는 경우도 있다.<br>
<img src = "./그림 9.1.png"/><br>
같은 대상이라도 지칭하는 요어가 다를 수 있기 때문에 한 개의 모델로 모든 하위 도메인을 표현하려는 시도는 올바른 방법이 아니며 표현할 수 없다.<br>
하위 도메인마다 사용하는 용어가 다르기 때문에 올바른 도메인 모델을 개발하려면 하위 도메
인마다 모델을 만들어야 한다.

모델은 특정한 컨텍스트(문맥)하에서 완전한 의미를 갖는다.<br>
같은 제품이라도 카탈로그 컨텍스트와 재고 컨텍스트에서 의미가 서로 다르다.<br>
이렇게 `구분되는 경계를 갖는 컨텍스트를 DDD에서는 바운디드 컨텍스트(Bounded Context)`라고 부릅니다.

## 9.2 바운디드 컨텍스트
바운디드 컨텍스트는 모델의 경계를 결정하며 한 개의 바운디드 컨텍스트는 논리적으로 한 개의 모델을 갖는다.<br>
바운디드 컨텍스트는 용어를 기준으로 구분한다.<br>
바운디드 컨텍스트는 실제로 사용자에게 기능을 제공하는 물리적 시스템으로 도메인 모델은 이 바운디드 컨텍스트 안에서 도메인을 구현한다.

이상적으로 하위 도메인과 바운디드 컨텍스트가 일대일 관계를 가지면 좋겠지만 현실은 그렇지 않을 때가 많다.<br>
바운디드 컨텍스트는 기업의 팀 조직 구조에 따라 결정되기도 한다.<br>
용어를 명확하게 구분하지 못해 두 하위 도메인을 하나의 바운디드 컨텍스트에서 구현하기도 한다.
<img src = "./그림 9.2.png"/><br>

규모가 작은 기업은 전체 시스템을 한 개팀에서 구현할 때도 있다.<br>
여러 하위 도메인을 한 개의 바운디드 컨텍스트에서 구현한다.<br>
여러 하위 도메인을 하나의 바운디드 컨텍스트에서 개발할 때 주의할 점은 하위 도메인의 모델이 섞이지 않도록 하는 것이다.<br>
한 프로젝트에 각 하위 도메인의 모델이 위치하면 아무래도 전체 하위 도메인을 위한 단일 모델을 만들고 싶은 유혹에 빠지기 쉽다.<br>
비록 한 개의 바운디드 컨텍스트가 여러 하위 도메인을 포함하더라도 하위 도메인마다 구분되는 패키지를 갖도록 구현하며, 하위 도메인을 위한 모델이 뒤섞이지 않도록 하는 효과를 낼 수있다.<br>
<img src = "./그림 9.3.png"/><br>

바운디드 컨텍스트는 도메인 모델을 구분하는 경계가 되기 때문에 바운디드 컨텍스트는 구현하는 하위 도메인에 알맞은 모델을 포함합니다.<br>
<img src = "./그림 9.4.png"/><br>

## 9.3 바운디드 컨텍스트 구현
바운디드 컨텍스트가 도메인 모델만 포함하는 것은 아니며, 도메인 기능을 사용자에게 제공하는 데 필요한 표현 영역, 응용 서비스, 인프라스트럭처 영역을 모두 포함한다.<br>
도메인 모델의 데이터 구조가 바뀌면 DB 테이블 스키마도 함께 변경해야 하므로 테이블도 바운디드 컨텍스트에 포함된다.<br>
<img src = "./그림 9.5.png"/><br>

모든 바운디드 컨텍스트를 반드시 도메인 주도로 개발할 필요는 없다.<br>
복잡한 도메인 로직을 갖지 않은 경우엔 서비스-DAO 구조로 CRUD 방식으로 구현해도 된다.<br>
<img src = "./그림 9.6.png"/><br>

한 바운디드 컨텍스트에서 두 방식을 혼합해서 사용할 수도 있다.<br>
대표적인 예가 CQRS 패턴이다.<br>
CQRS(Command Query Responsibility Segregation)는 상태를 변경하는 명령 기능과 내용을 조회하는 쿼리 기능을 위한 모델을 구분하는 패턴이다.<br>
<img src = "./그림 9.7.png"/><br>

각 바운디드 컨텍스트는 서로 다른 구현 기술을 사용할 수도 있다.<br>
바운디드 컨텍스트가 반드시 사용자에게 보여지는 UI를 가지고 있어야 하는 것은 아니며 JSON 데이터를 알맞게 가공해서 응답할 수도 있다.<br>

## 9.4 바운디드 컨텍스트 간 통합
온라인 쇼핑 사이트에서 매출 증대를 위해 카탈로그 하위 도메인에 개인화 추천 기능을 도입하 기로 했다고 하는 경우 기존 카탈로그 시스템을 개발하던 팀과 별도로 추천 시스템을 담당하는 팀 이 새로 생겨서 이 팀에서 주도적으로 추천 시스템을 만들기로 가정을 했다. 이 경우 카탈로그 하 위 도메인에는 기존 카탈로그를 위한 바운디드 컨텍스트와 추천 기능을 위한 바운디드 컨텍스트가 생긴다.<br>
<img src = "./그림 9.10.png"/><br>

두 팀이 관련된 바운디드 컨텍스트를 개발하면 자연스럽게 두 바운디드 컨텍스트 간 통합이 발생한다.
* 사용자가 제품 상세 페01지를 볼 때, 보고 있는 상품과 유사한 상품 목록을 하단에 보여준다.

카탈로그 컨텍스트와 추천 컨텍스트의 도메인 모델은 서로 다르다.<br>
카탈로그는 제품을 중심으로 도메인 모델을 구현하지만 추천은 추천 연산을 위한 모델을 구현한다.<br>

카탈로그 시스템은 추천 시스템으로부터 추천 데이터를 받아오지만, 카탈로그 시스템에서는 추천의 도메인 모델을 사용하기보다는 카탈로그 도메인 모델을 사용해서 추천 상품을 표현해야 한다.<br>
```
// 상품 추천 기능을 표현하는 도메인 서비스
public interface ProductRecommendationService {
    List<Product> getRecommendationOf(ProductId id);
}
```

도메인 서비스를 구현한 클래스는 인프라스트럭처 영역에 위치한다.<br>
이 클래스는 외부 시스템과의 연동을 처리하고 외부 시스템의 모델과 현재 도메인 모델 간의 변환을 책임진다.<br>
<img src = "./그림 9.11.png"/><br>

외부 추천 시스템이 제공하는 API는 카탈로그 도메인 모델과 일치하지 않을 수 있다.
```
[
    {itemID: 'PROD-1000', type: 'PRODUCT', rank: 100},
    {itemID: 'PROD-1001', type: 'PRODUCT', rank: 54}
]
```

RecSystemClient는 REST API로부터 데이터를 읽어와 카탈로그 도메 인에 맞는 상품 모델로 변환한다.
```
public class RecSystemClient implements ProductRecommendationService {

  private ProductRepository productRepository;

  @Override
  public List<Product> getRecommendationOf(ProductId id) {
    List<Recommendation> items = getRecItems(id.getValue());
    return toProducts(items);
  }

  private List<RecommendationItem> getRecItems(String itemId) {
    // externalRecClient는 외부 추천 시스템을 위한 클라이언트라고 가정
    return externalRecClient.getRecs(itemId);
  }

  private List<Product> toProducts(List<RecommendationItem> items) {
    return items.stream()
        .map(item -> toProductId(item.getItemId()))
        .map(prodId -> productRepository.findById(prodId))
        .collect(toList());
  }

  private ProductId toProductId(String itemId) {
    return new ProductId(itemId);
  }
```

두 모델 간의 변환 과정이 복잡하면 변환 처리를 위한 별도 클래스를 만들고 이 클래스에서 변환을 처리해도 된다.
<img src = "./그림 9.12.png"/><br>

REST API를 호출하는 것은 두 바운디드 컨텍스트를 직접 통합하는 방법이며 직접 통합하는 대신 간접적으로 통합하는 방법도 있다.<br>
대표적으로 메시지 큐를 사용하는 것이다.<br>
<img src = "./그림 9.13.png"/><br>

메세지 큐를 사용할 경우 두 바운디드 컨텍스트가 사용할 메세지의 데이터 구조를 맞춰야 한다.<br>
각각의 바운디드 컨텍스트를 담당하는 팀은 서로 만나서 주고받을 데이터 형식에 대해 협의해야 한다.<br>

어떤 도메인 관점에서 모델을 사용하느냐에 따라 두 바운디드 컨텍스트의 구현 코드가 달라지 게 된다.<br>
<img src = "./그림 9.14.png"/><br>
<img src = "./그림 9.15.png"/><br>

두 바운디드 컨텍스트를 개발하는 팀은 메시징 큐에 담을 데이터의 구조를 협의하게 되는데 그 큐를 누가 제공하느냐에 따라 데이터 구조가 결정된다.<br>
한쪽에서 메세지를 출판하고 다른 쪽에서 구독하는 출판/구독 모델을 따른다.<br>
<img src = "./그림 9.16.png"/><br>

큐로 인해 `비동기`로 데이터를 전달하는 것을 제외하면 REST API를 사용해서 데이터를 전달하는 것과 차이가 없다.<br>

## 9.5 바운디드 컨텍스트 간 관계
바운디드 컨텍스트는 어떤 식으로든 연결되기 때문에 두 바운디드 컨텍스트는 다양한 방식으로 관계를 맺는다.<br>
두 바운디드 컨텍스트간 관계 중 가장 흔한 관계는 한쪽에서 API 를 제공하고 다른 한쪽에서는 그 API 를 호출하는 관계이다.<br>
이 관계에서 API 를 사용하는 바운디드 컨텍스트는 API 를 제공하는 바운디드 컨텍스트에 의존하게 된다.<br>
<img src = "./그림 9.17.png"/><br>

상류 컴포넌트는 일종의 서비스 공급자 역할을 하며 하류 컴포넌트는 그 서비스를 사용하는 고 객 역할을 한다.<br>
고객과 공급자 관계에 있는 두 팀은 상호 협력이 필수적이다.<br>
상류 팀과 하류 팀은 개발 계획을 서로 공유하고 일정을 협의해야 한다.<br>

상류 컴포넌트는 보통 하류 컴포넌트가 사용할 수 있는 통신 포로토콜을 정의하고 이를 공개한다.<br>
상류 팀의 고객인 하류 팀이 다수 존재하면 상류 팀은 여러 하류 팀의 요구사항을 수용할 수 있는 API를 만들고 이를 서비스 형태로 공개해서 서비스의 일관성을 유지할 수 있다.<br>
이런 서비스를 가리켜 `공개 호스트 서비스(OPEN HOST SERVICE)`라고 한다.<br>

공개 호스트 서비스의 대표적인 예는 검색이다.<br>
이때 상류 컴포넌트는 검색 시스템이고, 하류 컴포넌트는 블로그, 카페, 게시판등이 된다.<br>
상류 팀은 각 하류 컴포넌트의 요구사항을 수용하는 단일 API 를 만들어 이를 공개하고 각 하류 팀은 공개된 API를 사용해서 검색 기능을 구현한다.
<img src = "./그림 9.18.png"/><br>

상류 컴포넌트의 서비스는 상류 바운디드 컨텍스트의 도메인 모델을 따른다.<br>
하류 컴포넌트는 상류 서비스의 모델이 자신의 도메인 모델에 영향을 주지 않도록 보호해주는 완충 지대를 만들어야 한다.<br>
<img src = "./그림 9.19.png"/><br>

내 모델이 깨지는 것을 막아주는 안티코럽션 계층이 된다.<br>
이 계층에서 두 바운디드 컨텍스트 간의 모델 변환을 처리 해 주기 때문에 다른 바운디드 컨텍스트의 모델에 영향을 받지 않고 내 도메인 모델을 유지할 수 있다.<br>

두 바운디드 컨텍스트가 같은 모델을 공유하는 경우도 있다.<br>
모델을 공유함으로써 중복 설계를 막을 수 있다.<br>
두 팀이 공유하는 모델을 `공유 커널(SHARED KERNEL)`이라고 부른다.<br>
공유 커널의 장점은 중복을 줄여준다는 것이다.<br>
두 팀이 하나의 모델을 개발해서 공유하기 때 문에 두 팀에서 동일한 모델을 두 번 개발하는 중복을 줄일 수 있다.<br>
두 팀이 밀접한 관계를 형성할 수 없다면 공유 커널을 사용할 때의 장점보다 공유 커널로 인해 개발이 지연되고 정체되는 문제가 더 커지게 된다.<br>

서로 통합하지 않는 방식을 `독립 방식(SEPARATE WAY)`이라고 한다.<br>
두 바운디드 컨텍스트 간에 통합하지 않으므로 서로 독립적으로 모델을 발전시킨다.<br>
독립 방식에서 두 바운디드 컨텍스트 간의 통합은 수동으로 이루어진다.<br>
<img src = "./그림 9.20.png"/><br>

수동으로 통합하는 방식이 나쁜 것은 아니지만 규모가 커질수록 수동 통합에는 한계가 있으므 로 규모가 커지기 시작하면 두 바운디드 컨텍스트를 통합해야 한다.<br>
두 바운디드 컨텍스트를 완전히 대체할 수 없다면 두 바운디드 컨텍스트를 통합해주는 별도의 시스템을 만들어야 할 수도 있다.<br>
<img src = "./그림 9.21.png"/><br>

## 9.6 컨텍스트 맵
개별 바운디드 컨텍스트에 매몰되면 전체를 보지 못할 때가 있다.<br>
나무만 보고 숲을 보지 못하 는 상황을 방지하려면 전체 비즈니스를 조망할 수 있는 지도가 필요한데 그것이 바로 `컨텍스트 맵`이다.
<img src = "./그림 9.22.png"/><br>

그림만 봐도 한눈에 각 바운디드 컨텍스트의 경계가 명확하게 드러나고 서로 어떤 관계를 맺 고 있는지 알 수 있다.<br>
바운디드 컨텍스트 영역에 주요 애그리거트를 함께 표시하면 모델에 대 한 관계가 더 명확히 드러난다.<br>
오픈 호스트 서비스(OHS)와 안티코럽션 계층 (ACL)만 표시됬는데 하위 도메인이나 조직 구조를 함께 표시하면 도메인을 포함한 전체 관계를 이해하는데 도움이 된다.<br>

컨텍스트 맵을 그리는 규칙은 따로 없다.<br>
간단한 도형과 선을 이용해서 각 컨텍스트의 관계를 이해할 수 있는 수준에서 그리면 된다.<br>