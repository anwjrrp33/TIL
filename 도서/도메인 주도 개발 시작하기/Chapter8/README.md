# 8 애그리거트 트랜잭션 관리

## 8.1 애그리거트와 트랜잭션
한 주문 애그리거트에 대해 운영자는 배송상태로 변경하고 사용자는 배송지 주소를 변경하면 트랜잭션이 필요하다.

<img src="./그림 8.1.png">

트랜잭션마다 리포지터리는 새로운 애그리거트 객체를 생성하므로 운영자 스레드와 고객 스레드는 같은 주문 애그리거트를 나타내는 다른 객체를 구하게 된다.

운영자 스레드와 고객 스레드는 개념적으로 동일한 애그리거트지만 물리적으론 서로 다른 애그리거트 객체를 사용하는데 운영자 스레드에서 배송 상태를 변경해도 고객 스레드에서 사용하는 주문 애그리거트 객체에는 영향이 없기 때문에 고객 스레드에선 배송 전이기 때문에 배송지 변경이 가능한 상황이 발생한다.

두 스레드는 각각 트랜잭션을 커밋할 때 수정한 내용을 DB에 반영한다. 이 시점에서 배송 상태도 변경되고, 배송지 정보보 변경되는데 애그리거트의 일관성이 깨지게 된다.

일관성이 깨지지 않도록 하려면 두 가지 중 하나를 해야한다.
* 운영자가 배송지 정보를 조회하고 상태를 변경하는 동안, 고객이 애그리거트를 수정하지 못하게 막는다.
* 운영자가 배송지 정보를 조회한 이후에 고객이 정보를 변경하면, 운영자가 애그리거트를 다시 조회한 뒤 수정하도록 한다.

애그리거트에 대해 사용할 수 있는 대표적인 트랜잭션 처리 방식에는 선점(Pessimistic) 잠금과
비선점(Optimistic) 잠금의 두 가지 방식이 있다. Pessimistic Lock(비관적 잠금), Optimistic(낙관적 잠금)이라는 용어를 쓰기도 하는데 책에선 선점 잠금과, 비선점 잠금이란 용어를 사용한다.

## 8.2 선점 잠금
`선점 잠금`은 먼저 애그리거트를 구한 스레드가 애그리거트 사용이 끝날 때까지 다른 스레드가 해당 애그리거트를 수정하지 못하게 하는 방식이다.

<img src="./그림 8.2.png">

* 스레드1이 선점 잠금 방식으로 애그리거트를 구한 뒤 이어서 스레드2가 같은 애그리거트를 구하고 있다. 이때 스레드2는 스레드1이 애그리거트에 대한 잠금을 해제할 때까지 블로킹 Blocking된다.
* 스레드1이 수정 후 커밋을 하면 잠금이 해제된다. 이때 대기하고 있던 스레드2가 애그리거트에 접근한다.
* 스레드1이 커밋한 뒤 스레드2가 애그리거트를 구하게 되서 스레드1이 수정한 애그리거트를 보게 된다.

한 스레드가 애그리거트를 구하고 수정하는 동안 다른 스레드가 수정할 수 없으므로 동시에 애
그리거트를 수정할 때 발생하는 데이터 충돌 문제를 해소할 수 있다.

<img src="./그림 8.3.png">

* 운영자 스레드가 먼저 선점 잠금 방식으로 주문 애그리거트를 구하면 운영자 스레드가 잠금을
해제할 때까지 고객 스레드는 대기 상태가 된다.
* 운영자 스레드가 배송 상태로 변경한 뒤 트랜 잭션을 커밋하면 잠금을 해제한다.
* 배송 상태이므로 주문 애그리거트는 배송지 변경 시 에러를 발생하고 트랜잭션은 실패하게 된다. 이 시점에 고객은 "이미 배송이 시작되어 배송지를 변경할 수 없습니다"와 같은 안내 문구를 보게 된다.

선점 잠금은 보통 DBMS 가 제공하는 행 단위 잠금을 사용해서 구현한다. 오라클을 비롯한 다수 DBMS 가 for update 와 같은 쿼리를 사용해서 특정 레코드에 한 사용자만 접근할 수 있는 잠금 장치를 제공한다.

JPA의 EntityManager를 사용할 경우 LockModeType.PESSIMISTIC_WRITE 사용한다. 스프링 데이터 JPA 사용시 @Lock(LockModeType.PESSIMISTIC_WRITE) 사용한다.
* JPA EntityManager는 LockModeType을 인자로 받는 find () 메서드를 제공한다.
LockModeType.PESSIMISTIC_WRITE를 값으로 전달하면 해당 엔티티와 매핑된 테이블을
이용해서 선점 잠금 방식을 적용한다.
    ```
    // JPA EntityManager는 LockModeType을 인자로 받는 find() 메서드를 제공한다.
    Order order = entityManager.find(Order.class, orderNo, LockModeType.PESSIMISTIC_WRITE);
    ```
* JPA 프로바이더와 DBMS에 따라 잠금 모드 구현이 다르다. 하이버네이트의 경우 PESSIMISTIC_WRITE를 잠금 모드로 사용하면 for update 쿼리를 이용해서 선점 잠금을 구현한다.
    ```
    // 스프링 데이터 JPA는 @Lock 애너테이션을 사용해서 잠금 모드를 지정한다.
    public interface MemberRepository extends Repository<Member, MemberId> {
        @Lock(LockModeType.PESSIMISTICJWRITE)
        @Query("select m from Member m where m.id = :id")
        Optional<Member> findByIdForUpdate(@Param("id") MemberId memberId);
    }
    ```

### 8.2.1 선점 잠금과 교착 상태
선점 잠금 기능을 사용할 때는 잠금 순서에 따른 교착 상태(deadlock)가 발생하지 않도록 주의해야한다.

예를 들어 다음과 같은 순서로 두 스레드가 잠금 시도를 한다.
1. 스레드1: A 애그리거트에 대한 선점 잠금 구함
2. 스레드2: B 애그리거트에 대한 선점 잠금 구함
3. 스레드1: B 애그리거트에 대한 선점 잠금 시도
4. 스레드2: A 애그리거트에 대한 선점 잠금 시도

이 순서에 따르면 스레드1은 영원히 B애그리거트에 대한 선점 잠금을 구할 수 없다. 스레드2가 B애그리거트에 대한 잠금을 이미 선점하고 있기 때문인데, 동일한 이유로 스레드2는 A애그리거트에 대한 잠금을 구할 수 없다. 두 스레드는 상대방 스레드가 먼저 선점한 잠금을 구할 수 없어 더 이상 다음 단계를 진행하지 못하게 되고, 스레드1과 스레드2는 `교착 상태`에 빠지게 된다.