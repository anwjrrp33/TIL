# 1.1 디자인 패턴

## 개요

디자인 패턴이란 프로그램을 설계할 때 발생했던 문제점들을 객체 간의 상호 관계 등을 이용하여 해결할 수 있도록 하나의 '규약' 형태로 만들어 놓은 것을 의미합니다.

---

## 1.1.1 싱글톤 패턴

### 정의
싱글톤 패턴(singleton pattern)은 하나의 클래스에 오직 하나의 인스턴스만 가지는 패턴입니다.

### 특징
- 하나의 클래스를 기반으로 단 하나의 인스턴스를 만들어 사용
- 주로 데이터베이스 연결 모듈에 많이 사용
- 인스턴스 생성 비용이 줄어드는 장점
- 의존성이 높아지는 단점

### JavaScript 구현

#### 기본 구현
```javascript
class Singleton {
  constructor() {
    if (!Singleton.instance) {
      Singleton.instance = this
    }
    return Singleton.instance
  }

  getInstance() {
    return this.instance
  }
}

const a = new Singleton()
const b = new Singleton()
console.log(a === b) // true
```

#### 데이터베이스 연결 모듈
```javascript
const URL = 'mongodb://localhost:27017/kundolapp'
const createConnection = url => ({"url": url})

class DB {
  constructor(url) {
    if (!DB.instance) {
      DB.instance = createConnection(url)
    }
    return DB.instance
  }

  connect() {
    return this.instance
  }
}

const a = new DB(URL)
const b = new DB(URL)
console.log(a === b) // true
```

### Java 구현
```java
class Singleton {
  private static class singleInstanceHolder {
    private static final Singleton INSTANCE = new Singleton();
  }

  public static Singleton getInstance() {
    return singleInstanceHolder.INSTANCE;
  }
}

public class HelloWorld {
  public static void main(String[] args) {
    Singleton a = Singleton.getInstance();
    Singleton b = Singleton.getInstance();
    System.out.println(a.hashCode());
    System.out.println(b.hashCode());
    if (a == b) {
      System.out.println(true);
    }
  }
}
```

### 실제 사용 예

#### Mongoose의 싱글톤 패턴
```javascript
Mongoose.prototype.connect = function(uri, options, callback) {
  const _mongoose = this instanceof Mongoose ? this : mongoose;
  const conn = _mongoose.connection;

  return _mongoose._promiseOrCallback(callback, cb => {
    conn.openUri(uri, options, err => {
      if (err != null) {
        return cb(err);
      }
      return cb(null, _mongoose);
    });
  });
};
```

#### MySQL의 싱글톤 패턴
```javascript
// 메인 모듈
const mysql = require('mysql');
const pool = mysql.createPool({
  connectionLimit: 10,
  host: 'example.org',
  user: 'kundol',
  password: 'secret',
  database: '승철이디비'
});

pool.connect();

// 모듈 A
pool.query(query, function(error, results, fields) {
  if (error) throw error;
  console.log('The solution is: ', results[0].solution);
});
```

### 싱글톤 패턴의 단점

#### TDD 문제
- 단위 테스트는 테스트가 서로 독립적이어야 함
- 싱글톤 패턴은 미리 생성된 하나의 인스턴스를 기반으로 구현하므로 각 테스트마다 독립적인 인스턴스를 만들기 어려움

#### 의존성 주입 (DI, Dependency Injection)
- 모듈 간의 결합을 느슨하게 만들어 해결 가능
- 메인 모듈이 간접적으로 의존성을 주입하는 방식

**의존성 주입의 장점:**
- 모듈들을 쉽게 교체할 수 있는 구조
- 테스팅하기 쉽고 마이그레이션하기 수월
- 애플리케이션 의존성 방향이 일관됨
- 모듈 간의 관계가 명확해짐

**의존성 주입의 단점:**
- 클래스 수가 늘어나 복잡성 증가
- 약간의 런타임 페널티 발생

**의존성 주입 원칙:**
- 상위 모듈은 하위 모듈에서 어떠한 것도 가져오지 않아야 함
- 둘 다 추상화에 의존해야 함
- 추상화는 세부 사항에 의존하지 말아야 함

---

## 1.1.2 팩토리 패턴

### 정의
팩토리 패턴(factory pattern)은 객체를 사용하는 코드에서 객체 생성 부분을 떼어내 추상화한 패턴입니다.

### 특징
- 상위 클래스가 중요한 뼈대를 결정
- 하위 클래스에서 객체 생성에 관한 구체적인 내용을 결정
- 상위/하위 클래스가 분리되어 느슨한 결합
- 더 많은 유연성을 가짐
- 유지 보수성 증가

### JavaScript 구현

#### 기본 예제
```javascript
const num = new Object(42)
const str = new Object('abc')
num.constructor.name; // Number
str.constructor.name; // String
```

#### 커피 팩토리 예제
```javascript
class Latte {
  constructor() {
    this.name = "latte"
  }
}

class Espresso {
  constructor() {
    this.name = "Espresso"
  }
}

class LatteFactory {
  static createCoffee() {
    return new Latte()
  }
}

class EspressoFactory {
  static createCoffee() {
    return new Espresso()
  }
}

const factoryList = { LatteFactory, EspressoFactory }

class CoffeeFactory {
  static createCoffee(type) {
    const factory = factoryList[type]
    return factory.createCoffee()
  }
}

const main = () => {
  // 라떼 커피를 주문한다.
  const coffee = CoffeeFactory.createCoffee("LatteFactory")
  // 커피 이름을 부른다.
  console.log(coffee.name) // latte
}

main()
```

### Java 구현
```java
abstract class Coffee {
  public abstract int getPrice();

  @Override
  public String toString() {
    return "Hi this coffee is " + this.getPrice();
  }
}

class CoffeeFactory {
  public static Coffee getCoffee(String type, int price) {
    if ("Latte".equalsIgnoreCase(type)) return new Latte(price);
    else if ("Americano".equalsIgnoreCase(type)) return new Americano(price);
    else {
      return new DefaultCoffee();
    }
  }
}

class Latte extends Coffee {
  private int price;

  public Latte(int price) {
    this.price = price;
  }

  @Override
  public int getPrice() {
    return this.price;
  }
}

// 사용 예
Coffee latte = CoffeeFactory.getCoffee("Latte", 4000);
Coffee ame = CoffeeFactory.getCoffee("Americano", 3000);
```

---

## 1.1.3 전략 패턴

### 정의
전략 패턴(strategy pattern)은 정책 패턴(policy pattern)이라고도 하며, 객체의 행위를 바꾸고 싶은 경우 '직접' 수정하지 않고 전략이라고 부르는 '캡슐화한 알고리즘'을 컨텍스트 안에서 바꿔주면서 상호 교체가 가능하게 만드는 패턴입니다.

### Java 구현 - 결제 전략

```java
interface PaymentStrategy {
  public void pay(int amount);
}

class KAKAOCardStrategy implements PaymentStrategy {
  private String name;
  private String cardNumber;
  private String cvv;
  private String dateOfExpiry;

  public KAKAOCardStrategy(String nm, String ccNum, String cvv, String expiryDate) {
    this.name = nm;
    this.cardNumber = ccNum;
    this.cvv = cvv;
    this.dateOfExpiry = expiryDate;
  }

  @Override
  public void pay(int amount) {
    System.out.println(amount + " paid using KAKAOCard.");
  }
}

class LUNACardStrategy implements PaymentStrategy {
  private String emailId;
  private String password;

  public LUNACardStrategy(String email, String pwd) {
    this.emailId = email;
    this.password = pwd;
  }

  @Override
  public void pay(int amount) {
    System.out.println(amount + " paid using LUNACard.");
  }
}

class ShoppingCart {
  List<Item> items;

  public void pay(PaymentStrategy paymentMethod) {
    int amount = calculateTotal();
    paymentMethod.pay(amount);
  }
}

// 사용 예
ShoppingCart cart = new ShoppingCart();
cart.pay(new LUNACardStrategy("kundol@example.com", "pukubababo"));
cart.pay(new KAKAOCardStrategy("Ju hongchul", "123456789", "123", "12/01"));
```

### passport의 전략 패턴

Passport는 Node.js에서 인증 모듈을 구현할 때 쓰는 미들웨어 라이브러리로, 여러 가지 '전략'을 기반으로 인증할 수 있게 합니다.

```javascript
var passport = require('passport')
  , LocalStrategy = require('passport-local').Strategy;

passport.use(new LocalStrategy(
  function(username, password, done) {
    User.findOne({ username: username }, function(err, user) {
      if (err) { return done(err); }
      if (!user) {
        return done(null, false, { message: 'Incorrect username.' });
      }
      if (!user.validPassword(password)) {
        return done(null, false, { message: 'Incorrect password.' });
      }
      return done(null, user);
    });
  }
));
```

---

## 1.1.4 옵저버 패턴

### 정의
옵저버 패턴(observer pattern)은 주체가 어떤 객체(subject)의 상태 변화를 관찰하다가 상태 변화가 있을 때마다 메서드 등을 통해 옵저버 목록에 있는 옵저버들에게 변화를 알려주는 디자인 패턴입니다.

### 특징
- 주체: 객체의 상태 변화를 보고 있는 관찰자
- 옵저버: 객체의 상태 변화에 따라 추가 변화 사항이 생기는 객체들
- 주로 이벤트 기반 시스템에 사용
- MVC(Model-View-Controller) 패턴에도 사용

### Java 구현

```java
interface Subject {
  public void register(Observer obj);
  public void unregister(Observer obj);
  public void notifyObservers();
  public Object getUpdate(Observer obj);
}

interface Observer {
  public void update();
}

class Topic implements Subject {
  private List<Observer> observers;
  private String message;

  public Topic() {
    this.observers = new ArrayList<>();
    this.message = "";
  }

  @Override
  public void register(Observer obj) {
    if (!observers.contains(obj)) observers.add(obj);
  }

  @Override
  public void notifyObservers() {
    this.observers.forEach(Observer::update);
  }

  public void postMessage(String msg) {
    System.out.println("Message sended to Topic: " + msg);
    this.message = msg;
    notifyObservers();
  }
}

class TopicSubscriber implements Observer {
  private String name;
  private Subject topic;

  public TopicSubscriber(String name, Subject topic) {
    this.name = name;
    this.topic = topic;
  }

  @Override
  public void update() {
    String msg = (String) topic.getUpdate(this);
    System.out.println(name + ":: got message >> " + msg);
  }
}

// 사용 예
Topic topic = new Topic();
Observer a = new TopicSubscriber("a", topic);
Observer b = new TopicSubscriber("b", topic);
topic.register(a);
topic.register(b);
topic.postMessage("amumu is op champion!!");
```

### JavaScript 프록시 객체를 이용한 옵저버 패턴

#### 프록시 객체
프록시(proxy) 객체는 어떠한 대상의 기본적인 동작(속성 접근, 할당, 순회, 열거, 함수 호출 등)의 작업을 가로챌 수 있는 객체입니다.

**매개변수:**
- target: 프록시할 대상
- handler: target 동작을 가로채고 어떠한 동작을 할 것인지가 설정되어 있는 함수

```javascript
const handler = {
  get: function(target, name) {
    return name === 'name' ? `${target.a} ${target.b}` : target[name]
  }
}

const p = new Proxy({a: 'KUNDOL', b: 'IS AUMUMU ZANGIN'}, handler)
console.log(p.name) // KUNDOL IS AUMUMU ZANGIN
```

#### 프록시 객체를 이용한 옵저버 패턴 구현

```javascript
function createReactiveObject(target, callback) {
  const proxy = new Proxy(target, {
    set(obj, prop, value) {
      if (value !== obj[prop]) {
        const prev = obj[prop]
        obj[prop] = value
        callback(`${prop}가 [${prev}] >> [${value}]로 변경되었습니다.`)
      }
      return true
    }
  })
  return proxy
}

const a = {
  "형규": "솔로"
}

const b = createReactiveObject(a, console.log)
b.형규 = "솔로"
b.형규 = "커플"
// 형규가 [솔로] >> [커플]로 변경되었습니다.
```

### Vue.js 3.0의 옵저버 패턴

Vue.js 3.0에서 ref나 reactive로 정의하면 해당 값이 변경되었을 때 자동으로 DOM에 있는 값이 변경되는데, 이는 프록시 객체를 이용한 옵저버 패턴을 이용하여 구현한 것입니다.

---

## 1.1.5 프록시 패턴과 프록시 서버

### 프록시 패턴

#### 정의
프록시 패턴(proxy pattern)은 대상 객체(subject)에 접근하기 전 그 접근에 대한 흐름을 가로채 대상 객체 앞단의 인터페이스 역할을 하는 디자인 패턴입니다.

#### 용도
- 객체의 속성, 변환 등을 보완
- 보안
- 데이터 검증
- 캐싱
- 로깅

### 프록시 서버

#### 정의
프록시 서버(proxy server)는 서버와 클라이언트 사이에서 클라이언트가 자신을 통해 다른 네트워크 서비스에 간접적으로 접속할 수 있게 해주는 컴퓨터 시스템이나 응용 프로그램을 가리킵니다.

#### nginx를 프록시 서버로 사용

**특징:**
- 비동기 이벤트 기반 구조
- 다수의 연결을 효과적으로 처리 가능
- 주로 Node.js 서버 앞단의 프록시 서버로 활용

**장점:**
- 익명 사용자가 직접적으로 서버에 접근하는 것을 차단
- 실제 포트를 숨길 수 있음
- 정적 자원을 gzip 압축
- 메인 서버 앞단에서 로깅 가능

#### CloudFlare

**특징:**
- 전 세계적으로 분산된 서버
- CDN 서비스 제공
- 웹 서버 앞단에 프록시 서버로 활용

**용도:**
- DDOS 공격 방어
- HTTPS 구축
- 의심스러운 트래픽 차단

**DDOS 공격 방어:**
- 짧은 기간 동안 네트워크에 많은 요청을 보내 네트워크를 마비시키는 공격
- 의심스러운 트래픽을 자동으로 차단
- 방화벽 대시보드 제공

### CORS와 프런트엔드의 프록시 서버

#### CORS (Cross-Origin Resource Sharing)
서버가 웹 브라우저에서 리소스를 로드할 때 다른 오리진을 통해 로드하지 못하게 하는 HTTP 헤더 기반 메커니즘입니다.

#### 해결 방법
프런트엔드에서 프록시 서버를 만들어 오리진을 변경

**예시:**
- 프런트엔드: 127.0.0.1:3000
- 백엔드: 127.0.0.1:12010
- 프록시 서버를 통해 오리진을 127.0.0.1:12010으로 변경

---

## 1.1.6 이터레이터 패턴

### 정의
이터레이터 패턴(iterator pattern)은 이터레이터(iterator)를 사용하여 컬렉션(collection)의 요소들에 접근하는 디자인 패턴입니다.

### 특징
- 순회할 수 있는 여러 가지 자료형의 구조와는 상관없이 이터레이터라는 하나의 인터페이스로 순회 가능

### JavaScript 구현

```javascript
const mp = new Map()
mp.set('a', 1)
mp.set('b', 2)
mp.set('c', 3)

const st = new Set()
st.add(1)
st.add(2)
st.add(3)

for (let a of mp) console.log(a)
for (let a of st) console.log(a)
/*
[ 'a', 1 ]
[ 'b', 2 ]
[ 'c', 3 ]
1
2
3
*/
```

다른 자료 구조인 Set과 Map임에도 똑같은 `for...of` 이터레이터 프로토콜을 통해 순회할 수 있습니다.

**용어:**
- 이터레이터 프로토콜: 이터러블한 객체들을 순회할 때 쓰이는 규칙
- 이터러블한 객체: 반복 가능한 객체로 배열을 일반화한 객체

---

## 1.1.7 노출모듈 패턴

### 정의
노출모듈 패턴(revealing module pattern)은 즉시 실행 함수를 통해 private, public 같은 접근 제어자를 만드는 패턴을 말합니다.

### 특징
- JavaScript는 private나 public 같은 접근 제어자가 존재하지 않음
- 전역 범위에서 스크립트가 실행됨
- 노출모듈 패턴을 통해 접근 제어자 구현

### JavaScript 구현

```javascript
const pukuba = (() => {
  const a = 1
  const b = () => 2
  const public = {
    c: 2,
    d: () => 3
  }
  return public
})()

console.log(pukuba)
console.log(pukuba.a)
// { c: 2, d: [Function: d] }
// undefined
```

- a와 b: private 범위 (다른 모듈에서 사용 불가)
- c와 d: public 범위 (다른 모듈에서 사용 가능)

**접근 제어자:**
- public: 클래스에 정의된 함수에서 접근 가능하며 자식 클래스와 외부 클래스에서 접근 가능한 범위
- protected: 클래스에 정의된 함수에서 접근 가능, 자식 클래스에서 접근 가능하지만 외부 클래스에서 접근 불가능한 범위
- private: 클래스에 정의된 함수에서 접근 가능하지만 자식 클래스와 외부 클래스에서 접근 불가능한 범위

---

## 1.1.8 MVC 패턴

### 정의
MVC 패턴은 모델(Model), 뷰(View), 컨트롤러(Controller)로 이루어진 디자인 패턴입니다.

### 특징
- 애플리케이션의 구성 요소를 세 가지 역할로 구분
- 각각의 구성 요소에만 집중해서 개발 가능
- 재사용성과 확장성이 용이
- 애플리케이션이 복잡해질수록 모델과 뷰의 관계가 복잡해지는 단점

### 구성 요소

#### 모델 (Model)
- 애플리케이션의 데이터
- 데이터베이스, 상수, 변수 등
- 뷰에서 데이터를 생성하거나 수정하면 컨트롤러를 통해 모델을 생성하거나 갱신

#### 뷰 (View)
- 사용자 인터페이스 요소
- inputbox, checkbox, textarea 등
- 모델을 기반으로 사용자가 볼 수 있는 화면
- 모델이 가지고 있는 정보를 따로 저장하지 않음
- 변경이 일어나면 컨트롤러에 전달

#### 컨트롤러 (Controller)
- 하나 이상의 모델과 하나 이상의 뷰를 잇는 다리 역할
- 이벤트 등 메인 로직 담당
- 모델과 뷰의 생명주기 관리
- 모델이나 뷰의 변경 통지를 받으면 각각의 구성 요소에 해당 내용 전달

### 예시: 스프링 (Spring)

**특징:**
- 자바 플랫폼을 위한 오픈 소스 애플리케이션 프레임워크
- WEB MVC로 웹 서비스 구축

**장점:**
- @RequestParam, @RequestHeader, @PathVariable 등의 애너테이션을 기반으로 사용자의 요청 값 분석
- 사용자의 요청 유효성 검증
- 재사용 가능한 코드
- 테스트 용이
- 쉬운 리디렉션

---

## 1.1.9 MVP 패턴

### 정의
MVP 패턴은 MVC 패턴으로부터 파생되었으며 MVC에서 C에 해당하는 컨트롤러가 프레젠터(presenter)로 교체된 패턴입니다.

### 특징
- 뷰와 프레젠터는 일대일 관계
- MVC 패턴보다 더 강한 결합을 지닌 디자인 패턴

---

## 1.1.10 MVVM 패턴

### 정의
MVVM 패턴은 MVC의 C에 해당하는 컨트롤러가 뷰모델(view model)로 바뀐 패턴입니다.

### 특징
- 뷰모델은 뷰를 더 추상화한 계층
- 커맨드와 데이터 바인딩을 가짐
- 뷰와 뷰모델 사이의 양방향 데이터 바인딩 지원

### 장점
- UI를 별도의 코드 수정 없이 재사용 가능
- 단위 테스팅하기 쉬움

---

## 1.1.11 Repository 패턴 (현대적 활용)

### 정의
Repository 패턴은 데이터 저장소에 접근하는 로직을 캡슐화하여 비즈니스 로직과 데이터 접근 로직을 분리하는 패턴입니다.

### 특징
- 데이터 소스와 비즈니스 로직 사이의 중개자 역할
- 테스트하기 쉬운 구조 (Mock 객체 사용 가능)
- 데이터 소스 변경 시 Repository만 수정하면 됨
- Clean Architecture, DDD(Domain-Driven Design)에서 핵심 패턴

### TypeScript/NestJS 구현

```typescript
// 엔티티
interface User {
  id: string;
  name: string;
  email: string;
}

// Repository 인터페이스
interface IUserRepository {
  findById(id: string): Promise<User | null>;
  findAll(): Promise<User[]>;
  save(user: User): Promise<User>;
  delete(id: string): Promise<void>;
}

// 실제 구현
class UserRepository implements IUserRepository {
  constructor(private db: Database) {}

  async findById(id: string): Promise<User | null> {
    return await this.db.query('SELECT * FROM users WHERE id = ?', [id]);
  }

  async findAll(): Promise<User[]> {
    return await this.db.query('SELECT * FROM users');
  }

  async save(user: User): Promise<User> {
    return await this.db.query(
      'INSERT INTO users (id, name, email) VALUES (?, ?, ?)',
      [user.id, user.name, user.email]
    );
  }

  async delete(id: string): Promise<void> {
    await this.db.query('DELETE FROM users WHERE id = ?', [id]);
  }
}

// 서비스에서 사용
class UserService {
  constructor(private userRepository: IUserRepository) {}

  async getUser(id: string): Promise<User | null> {
    return await this.userRepository.findById(id);
  }
}
```

### Spring Data JPA 예제

```java
// Entity
@Entity
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String name;
    private String email;
    // getters, setters
}

// Repository
public interface UserRepository extends JpaRepository<User, Long> {
    Optional<User> findByEmail(String email);
    List<User> findByNameContaining(String name);
}

// Service
@Service
public class UserService {
    private final UserRepository userRepository;

    public UserService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }

    public User createUser(User user) {
        return userRepository.save(user);
    }

    public Optional<User> getUserById(Long id) {
        return userRepository.findById(id);
    }
}
```

---

## 1.1.12 Builder 패턴

### 정의
Builder 패턴은 복잡한 객체의 생성 과정과 표현 방법을 분리하여 동일한 생성 절차에서 서로 다른 표현 결과를 만들 수 있게 하는 패턴입니다.

### 특징
- 객체 생성 과정이 복잡할 때 유용
- 불변 객체(Immutable Object) 생성에 적합
- 메서드 체이닝을 통한 가독성 향상
- 필수/선택 파라미터를 명확히 구분 가능

### JavaScript/TypeScript 구현

```typescript
class Pizza {
  private size: string;
  private cheese: boolean = false;
  private pepperoni: boolean = false;
  private bacon: boolean = false;

  constructor(builder: PizzaBuilder) {
    this.size = builder.size;
    this.cheese = builder.cheese;
    this.pepperoni = builder.pepperoni;
    this.bacon = builder.bacon;
  }
}

class PizzaBuilder {
  size: string;
  cheese: boolean = false;
  pepperoni: boolean = false;
  bacon: boolean = false;

  constructor(size: string) {
    this.size = size;
  }

  addCheese(): PizzaBuilder {
    this.cheese = true;
    return this;
  }

  addPepperoni(): PizzaBuilder {
    this.pepperoni = true;
    return this;
  }

  addBacon(): PizzaBuilder {
    this.bacon = true;
    return this;
  }

  build(): Pizza {
    return new Pizza(this);
  }
}

// 사용 예
const myPizza = new PizzaBuilder('large')
  .addCheese()
  .addPepperoni()
  .addBacon()
  .build();
```

### Kotlin 구현 (Data Class with Named Parameters)

```kotlin
data class User(
    val id: String,
    val name: String,
    val email: String,
    val age: Int = 0,
    val address: String = "",
    val phoneNumber: String = ""
)

// 사용 예 - Named Parameters로 간결하게 표현
val user = User(
    id = "1",
    name = "홍길동",
    email = "hong@example.com",
    age = 30
)
```

---

## 1.1.13 Decorator 패턴 (현대적 활용)

### 정의
Decorator 패턴은 객체에 동적으로 새로운 책임을 추가할 수 있게 하는 패턴입니다. 기능 확장이 필요할 때 서브클래싱 대신 쓸 수 있는 유연한 대안입니다.

### TypeScript Decorator (Experimental)

```typescript
// 메서드 실행 시간 측정 Decorator
function measureTime(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
  const originalMethod = descriptor.value;

  descriptor.value = async function(...args: any[]) {
    const start = performance.now();
    const result = await originalMethod.apply(this, args);
    const end = performance.now();
    console.log(`${propertyKey} 실행 시간: ${end - start}ms`);
    return result;
  };

  return descriptor;
}

// 로깅 Decorator
function log(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
  const originalMethod = descriptor.value;

  descriptor.value = function(...args: any[]) {
    console.log(`Calling ${propertyKey} with args:`, args);
    const result = originalMethod.apply(this, args);
    console.log(`Result:`, result);
    return result;
  };

  return descriptor;
}

class UserService {
  @measureTime
  @log
  async createUser(name: string, email: string) {
    // 사용자 생성 로직
    return { id: '1', name, email };
  }
}
```

### Python Decorator

```python
import time
from functools import wraps

def timer(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        start = time.time()
        result = func(*args, **kwargs)
        end = time.time()
        print(f"{func.__name__} 실행 시간: {end - start:.2f}초")
        return result
    return wrapper

def cache(func):
    cached_results = {}

    @wraps(func)
    def wrapper(*args):
        if args in cached_results:
            print("캐시에서 가져옴")
            return cached_results[args]
        result = func(*args)
        cached_results[args] = result
        return result
    return wrapper

@timer
@cache
def fibonacci(n):
    if n < 2:
        return n
    return fibonacci(n-1) + fibonacci(n-2)
```

---

## 1.1.14 Adapter 패턴

### 정의
Adapter 패턴은 호환되지 않는 인터페이스를 가진 객체들이 협업할 수 있도록 하는 구조적 디자인 패턴입니다.

### TypeScript 구현

```typescript
// 기존 시스템
class OldPaymentSystem {
  processOldPayment(amount: number): void {
    console.log(`Old system: Processing payment of $${amount}`);
  }
}

// 새로운 인터페이스
interface NewPaymentProcessor {
  pay(amount: number, currency: string): void;
}

// Adapter
class PaymentAdapter implements NewPaymentProcessor {
  constructor(private oldSystem: OldPaymentSystem) {}

  pay(amount: number, currency: string): void {
    console.log(`Converting ${currency} to USD`);
    this.oldSystem.processOldPayment(amount);
  }
}

// 사용 예
const oldSystem = new OldPaymentSystem();
const adapter = new PaymentAdapter(oldSystem);
adapter.pay(100, 'KRW'); // 새로운 인터페이스로 구 시스템 사용
```

### 실제 사용 예: Axios Adapter

```typescript
// Axios는 브라우저와 Node.js에서 다른 HTTP 클라이언트를 사용하지만
// 동일한 인터페이스를 제공 (Adapter 패턴)
import axios from 'axios';

// 브라우저와 Node.js 모두에서 동일하게 동작
const response = await axios.get('https://api.example.com/data');
```

---

# APPENDIX: 최신 트렌드 디자인 패턴 (2024-2025)

## A. 마이크로서비스 아키텍처 패턴

### A.1 Saga 패턴

#### 정의
Saga 패턴은 마이크로서비스 환경에서 분산 트랜잭션을 관리하는 패턴입니다. 각 서비스의 로컬 트랜잭션을 순차적으로 실행하고, 실패 시 보상 트랜잭션을 실행합니다.

#### 특징
- 마이크로서비스 간 데이터 일관성 보장
- 두 가지 방식: Choreography(이벤트 기반), Orchestration(중앙 조정)
- 실패 시 보상(Compensation) 트랜잭션 실행

#### Choreography 방식 (이벤트 기반)

```typescript
// 주문 서비스
class OrderService {
  async createOrder(orderData: OrderData) {
    // 1. 주문 생성
    const order = await this.orderRepository.save(orderData);

    // 2. 이벤트 발행
    await this.eventBus.publish('OrderCreated', {
      orderId: order.id,
      userId: order.userId,
      amount: order.amount
    });
  }
}

// 결제 서비스
class PaymentService {
  @EventHandler('OrderCreated')
  async handleOrderCreated(event: OrderCreatedEvent) {
    try {
      // 결제 처리
      const payment = await this.processPayment(event.amount);

      // 성공 이벤트 발행
      await this.eventBus.publish('PaymentCompleted', {
        orderId: event.orderId,
        paymentId: payment.id
      });
    } catch (error) {
      // 실패 이벤트 발행
      await this.eventBus.publish('PaymentFailed', {
        orderId: event.orderId,
        reason: error.message
      });
    }
  }
}

// 주문 서비스 - 보상 트랜잭션
class OrderService {
  @EventHandler('PaymentFailed')
  async handlePaymentFailed(event: PaymentFailedEvent) {
    // 주문 취소 (보상 트랜잭션)
    await this.orderRepository.cancelOrder(event.orderId);
  }
}
```

### A.2 Circuit Breaker 패턴

#### 정의
Circuit Breaker 패턴은 분산 시스템에서 장애가 전파되는 것을 방지하는 패턴입니다. 서비스 호출 실패율이 임계값을 넘으면 회로를 차단하여 빠른 실패(Fail Fast)를 유도합니다.

#### 상태
- **Closed**: 정상 동작, 모든 요청 통과
- **Open**: 회로 차단, 모든 요청 즉시 실패
- **Half-Open**: 일부 요청만 통과시켜 복구 여부 확인

#### TypeScript 구현

```typescript
enum CircuitState {
  CLOSED,
  OPEN,
  HALF_OPEN
}

class CircuitBreaker {
  private state: CircuitState = CircuitState.CLOSED;
  private failureCount: number = 0;
  private successCount: number = 0;
  private nextAttempt: number = Date.now();

  constructor(
    private failureThreshold: number = 5,
    private successThreshold: number = 2,
    private timeout: number = 60000 // 1분
  ) {}

  async execute<T>(operation: () => Promise<T>): Promise<T> {
    if (this.state === CircuitState.OPEN) {
      if (Date.now() < this.nextAttempt) {
        throw new Error('Circuit breaker is OPEN');
      }
      this.state = CircuitState.HALF_OPEN;
    }

    try {
      const result = await operation();
      this.onSuccess();
      return result;
    } catch (error) {
      this.onFailure();
      throw error;
    }
  }

  private onSuccess(): void {
    this.failureCount = 0;

    if (this.state === CircuitState.HALF_OPEN) {
      this.successCount++;
      if (this.successCount >= this.successThreshold) {
        this.state = CircuitState.CLOSED;
        this.successCount = 0;
      }
    }
  }

  private onFailure(): void {
    this.failureCount++;
    this.successCount = 0;

    if (this.failureCount >= this.failureThreshold) {
      this.state = CircuitState.OPEN;
      this.nextAttempt = Date.now() + this.timeout;
    }
  }
}

// 사용 예
const breaker = new CircuitBreaker();

async function callExternalAPI() {
  return await breaker.execute(async () => {
    const response = await fetch('https://api.example.com/data');
    return response.json();
  });
}
```

### A.3 API Gateway 패턴

#### 정의
API Gateway는 모든 클라이언트 요청의 단일 진입점 역할을 하는 패턴입니다. 라우팅, 인증, 로깅, 요청/응답 변환 등을 담당합니다.

#### 특징
- 단일 진입점으로 보안 강화
- 클라이언트별 맞춤형 API 제공 (BFF - Backend For Frontend)
- 횡단 관심사(Cross-cutting Concerns) 처리

---

## B. 프론트엔드 현대 패턴

### B.1 Hooks 패턴 (React)

#### 정의
React Hooks는 함수형 컴포넌트에서 상태와 생명주기 기능을 사용할 수 있게 하는 패턴입니다.

#### 특징
- 클래스 컴포넌트 없이 상태 관리 가능
- 로직 재사용이 쉬움 (Custom Hooks)
- 컴포넌트 간 상태 관련 로직 공유

#### 구현 예제

```typescript
// Custom Hook
function useUser(userId: string) {
  const [user, setUser] = useState<User | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<Error | null>(null);

  useEffect(() => {
    async function fetchUser() {
      try {
        setLoading(true);
        const response = await fetch(`/api/users/${userId}`);
        const data = await response.json();
        setUser(data);
      } catch (err) {
        setError(err as Error);
      } finally {
        setLoading(false);
      }
    }

    fetchUser();
  }, [userId]);

  return { user, loading, error };
}

// 사용
function UserProfile({ userId }: { userId: string }) {
  const { user, loading, error } = useUser(userId);

  if (loading) return <div>Loading...</div>;
  if (error) return <div>Error: {error.message}</div>;
  if (!user) return <div>User not found</div>;

  return (
    <div>
      <h1>{user.name}</h1>
      <p>{user.email}</p>
    </div>
  );
}
```

### B.2 Provider 패턴

#### 정의
Provider 패턴은 여러 컴포넌트에서 데이터를 공유할 수 있게 하는 패턴입니다. React Context API나 전역 상태 관리에서 사용됩니다.

#### React Context 예제

```typescript
// Context 생성
interface ThemeContextType {
  theme: 'light' | 'dark';
  toggleTheme: () => void;
}

const ThemeContext = createContext<ThemeContextType | undefined>(undefined);

// Provider 컴포넌트
function ThemeProvider({ children }: { children: ReactNode }) {
  const [theme, setTheme] = useState<'light' | 'dark'>('light');

  const toggleTheme = () => {
    setTheme(prev => prev === 'light' ? 'dark' : 'light');
  };

  return (
    <ThemeContext.Provider value={{ theme, toggleTheme }}>
      {children}
    </ThemeContext.Provider>
  );
}

// Custom Hook
function useTheme() {
  const context = useContext(ThemeContext);
  if (!context) {
    throw new Error('useTheme must be used within ThemeProvider');
  }
  return context;
}

// 사용
function App() {
  return (
    <ThemeProvider>
      <Header />
      <Main />
    </ThemeProvider>
  );
}

function Header() {
  const { theme, toggleTheme } = useTheme();
  return (
    <header className={theme}>
      <button onClick={toggleTheme}>Toggle Theme</button>
    </header>
  );
}
```

### B.3 Compound Components 패턴

#### 정의
Compound Components 패턴은 여러 컴포넌트가 함께 작동하여 하나의 기능을 제공하는 패턴입니다.

#### 구현 예제

```typescript
// Select 컴포넌트 예제
interface SelectContextType {
  value: string;
  onChange: (value: string) => void;
}

const SelectContext = createContext<SelectContextType | undefined>(undefined);

function Select({ children, value, onChange }: {
  children: ReactNode;
  value: string;
  onChange: (value: string) => void;
}) {
  return (
    <SelectContext.Provider value={{ value, onChange }}>
      <div className="select">{children}</div>
    </SelectContext.Provider>
  );
}

function Option({ value, children }: { value: string; children: ReactNode }) {
  const context = useContext(SelectContext);
  if (!context) throw new Error('Option must be used within Select');

  return (
    <div
      className={`option ${context.value === value ? 'selected' : ''}`}
      onClick={() => context.onChange(value)}
    >
      {children}
    </div>
  );
}

// 사용
function App() {
  const [selected, setSelected] = useState('apple');

  return (
    <Select value={selected} onChange={setSelected}>
      <Option value="apple">Apple</Option>
      <Option value="banana">Banana</Option>
      <Option value="orange">Orange</Option>
    </Select>
  );
}
```

---

## C. 백엔드 현대 패턴

### C.1 CQRS 패턴

#### 정의
CQRS(Command Query Responsibility Segregation)는 명령(Command)과 조회(Query)의 책임을 분리하는 패턴입니다.

#### 특징
- 읽기와 쓰기 모델을 분리
- 복잡한 도메인에서 성능 최적화
- 읽기 전용 DB(Read Replica) 활용 가능

#### TypeScript 구현

```typescript
// Command (쓰기)
interface CreateUserCommand {
  name: string;
  email: string;
}

class UserCommandHandler {
  constructor(private userRepository: IUserRepository) {}

  async handle(command: CreateUserCommand): Promise<void> {
    const user = new User(command.name, command.email);
    await this.userRepository.save(user);

    // 이벤트 발행
    await this.eventBus.publish(new UserCreatedEvent(user.id));
  }
}

// Query (읽기)
interface GetUserQuery {
  userId: string;
}

interface UserDTO {
  id: string;
  name: string;
  email: string;
  createdAt: Date;
}

class UserQueryHandler {
  constructor(private readDatabase: ReadDatabase) {}

  async handle(query: GetUserQuery): Promise<UserDTO> {
    // 최적화된 읽기 전용 쿼리
    return await this.readDatabase.query(
      'SELECT id, name, email, created_at FROM user_view WHERE id = ?',
      [query.userId]
    );
  }
}
```

### C.2 Event Sourcing 패턴

#### 정의
Event Sourcing은 애플리케이션 상태의 모든 변경을 이벤트의 시퀀스로 저장하는 패턴입니다.

#### 특징
- 모든 변경 사항의 완전한 감사 로그
- 시간 여행(Time Travel) 가능 - 과거 상태 재구성
- 이벤트 리플레이로 새로운 읽기 모델 생성 가능

#### 구현 예제

```typescript
// 이벤트 정의
abstract class DomainEvent {
  constructor(
    public readonly aggregateId: string,
    public readonly occurredAt: Date = new Date()
  ) {}
}

class UserCreatedEvent extends DomainEvent {
  constructor(
    aggregateId: string,
    public readonly name: string,
    public readonly email: string
  ) {
    super(aggregateId);
  }
}

class UserEmailChangedEvent extends DomainEvent {
  constructor(
    aggregateId: string,
    public readonly newEmail: string
  ) {
    super(aggregateId);
  }
}

// Aggregate
class User {
  private id: string;
  private name: string;
  private email: string;
  private events: DomainEvent[] = [];

  static create(id: string, name: string, email: string): User {
    const user = new User();
    user.apply(new UserCreatedEvent(id, name, email));
    return user;
  }

  changeEmail(newEmail: string): void {
    this.apply(new UserEmailChangedEvent(this.id, newEmail));
  }

  // 이벤트 적용
  private apply(event: DomainEvent): void {
    if (event instanceof UserCreatedEvent) {
      this.id = event.aggregateId;
      this.name = event.name;
      this.email = event.email;
    } else if (event instanceof UserEmailChangedEvent) {
      this.email = event.newEmail;
    }
    this.events.push(event);
  }

  // 과거 이벤트로부터 상태 재구성
  static fromEvents(events: DomainEvent[]): User {
    const user = new User();
    events.forEach(event => user.apply(event));
    return user;
  }

  getUncommittedEvents(): DomainEvent[] {
    return this.events;
  }
}

// Event Store
class EventStore {
  private events: Map<string, DomainEvent[]> = new Map();

  async save(aggregateId: string, events: DomainEvent[]): Promise<void> {
    const existing = this.events.get(aggregateId) || [];
    this.events.set(aggregateId, [...existing, ...events]);
  }

  async getEvents(aggregateId: string): Promise<DomainEvent[]> {
    return this.events.get(aggregateId) || [];
  }
}
```

---

## D. 클라우드 네이티브 패턴

### D.1 Sidecar 패턴

#### 정의
Sidecar 패턴은 주 애플리케이션 컨테이너와 함께 보조 컨테이너를 배포하여 로깅, 모니터링, 프록시 등의 기능을 제공하는 패턴입니다.

#### 특징
- 애플리케이션 코드 변경 없이 부가 기능 추가
- 서비스 메시(Service Mesh)의 핵심 패턴
- Kubernetes에서 Pod 내 여러 컨테이너로 구현

#### Kubernetes 예제

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: myapp
spec:
  containers:
  # 주 애플리케이션
  - name: app
    image: myapp:1.0
    ports:
    - containerPort: 8080

  # Sidecar - 로깅
  - name: log-collector
    image: fluent-bit:latest
    volumeMounts:
    - name: logs
      mountPath: /var/log

  # Sidecar - 프록시 (Envoy)
  - name: envoy-proxy
    image: envoyproxy/envoy:latest
    ports:
    - containerPort: 9901

  volumes:
  - name: logs
    emptyDir: {}
```

### D.2 Retry 및 Backoff 패턴

#### 정의
일시적인 장애에 대응하기 위해 실패한 작업을 재시도하는 패턴입니다.

#### 구현 예제

```typescript
interface RetryOptions {
  maxAttempts: number;
  initialDelay: number;
  maxDelay: number;
  backoffMultiplier: number;
}

async function retryWithExponentialBackoff<T>(
  operation: () => Promise<T>,
  options: RetryOptions
): Promise<T> {
  let lastError: Error;
  let delay = options.initialDelay;

  for (let attempt = 1; attempt <= options.maxAttempts; attempt++) {
    try {
      return await operation();
    } catch (error) {
      lastError = error as Error;

      if (attempt === options.maxAttempts) {
        break;
      }

      console.log(`Attempt ${attempt} failed. Retrying in ${delay}ms...`);
      await sleep(delay);

      // Exponential backoff
      delay = Math.min(delay * options.backoffMultiplier, options.maxDelay);
    }
  }

  throw new Error(`Failed after ${options.maxAttempts} attempts: ${lastError.message}`);
}

// 사용 예
const result = await retryWithExponentialBackoff(
  () => fetch('https://api.example.com/data'),
  {
    maxAttempts: 5,
    initialDelay: 1000,
    maxDelay: 30000,
    backoffMultiplier: 2
  }
);
```

---

## E. 성능 최적화 패턴

### E.1 Lazy Loading 패턴

#### React Code Splitting

```typescript
import { lazy, Suspense } from 'react';

// 컴포넌트 지연 로딩
const HeavyComponent = lazy(() => import('./HeavyComponent'));

function App() {
  return (
    <Suspense fallback={<div>Loading...</div>}>
      <HeavyComponent />
    </Suspense>
  );
}
```

#### Image Lazy Loading

```typescript
function LazyImage({ src, alt }: { src: string; alt: string }) {
  const [imageSrc, setImageSrc] = useState<string | null>(null);
  const imgRef = useRef<HTMLImageElement>(null);

  useEffect(() => {
    const observer = new IntersectionObserver(
      (entries) => {
        entries.forEach((entry) => {
          if (entry.isIntersecting) {
            setImageSrc(src);
            observer.disconnect();
          }
        });
      },
      { threshold: 0.1 }
    );

    if (imgRef.current) {
      observer.observe(imgRef.current);
    }

    return () => observer.disconnect();
  }, [src]);

  return <img ref={imgRef} src={imageSrc || undefined} alt={alt} />;
}
```

### E.2 Memoization 패턴

```typescript
// React useMemo
function ExpensiveComponent({ data }: { data: number[] }) {
  const processedData = useMemo(() => {
    console.log('Processing data...');
    return data.map(x => x * 2).filter(x => x > 10);
  }, [data]);

  return <div>{processedData.join(', ')}</div>;
}

// JavaScript 메모이제이션
function memoize<T extends (...args: any[]) => any>(fn: T): T {
  const cache = new Map();

  return ((...args: any[]) => {
    const key = JSON.stringify(args);

    if (cache.has(key)) {
      return cache.get(key);
    }

    const result = fn(...args);
    cache.set(key, result);
    return result;
  }) as T;
}

// 사용 예
const expensiveOperation = memoize((n: number) => {
  console.log('Computing...');
  return n * n;
});

console.log(expensiveOperation(5)); // Computing... 25
console.log(expensiveOperation(5)); // 25 (캐시에서 가져옴)
```

---

## F. 보안 패턴

### F.1 Token Bucket 패턴 (Rate Limiting)

```typescript
class TokenBucket {
  private tokens: number;
  private lastRefill: number;

  constructor(
    private capacity: number,
    private refillRate: number // tokens per second
  ) {
    this.tokens = capacity;
    this.lastRefill = Date.now();
  }

  tryConsume(tokens: number = 1): boolean {
    this.refill();

    if (this.tokens >= tokens) {
      this.tokens -= tokens;
      return true;
    }

    return false;
  }

  private refill(): void {
    const now = Date.now();
    const timePassed = (now - this.lastRefill) / 1000;
    const tokensToAdd = timePassed * this.refillRate;

    this.tokens = Math.min(this.capacity, this.tokens + tokensToAdd);
    this.lastRefill = now;
  }
}

// Express 미들웨어 예제
const rateLimiter = new Map<string, TokenBucket>();

function rateLimitMiddleware(req, res, next) {
  const clientId = req.ip;

  if (!rateLimiter.has(clientId)) {
    rateLimiter.set(clientId, new TokenBucket(100, 10)); // 100 tokens, 10/sec refill
  }

  const bucket = rateLimiter.get(clientId)!;

  if (bucket.tryConsume()) {
    next();
  } else {
    res.status(429).json({ error: 'Too many requests' });
  }
}
```

---

## 최신 트렌드 요약

### 2024-2025 주요 트렌드

1. **서버리스 아키텍처**: Lambda 함수, Edge Functions 등 이벤트 드리븐 패턴
2. **Micro Frontends**: 프론트엔드를 마이크로서비스처럼 분리
3. **GraphQL Federation**: 여러 GraphQL 서비스를 하나로 통합
4. **AI/ML Integration**: AI 모델을 서비스에 통합하는 패턴
5. **Real-time Collaboration**: CRDT(Conflict-free Replicated Data Type) 패턴
6. **Edge Computing**: CDN Edge에서 실행되는 서버리스 함수

### 추천 학습 경로

1. **기본 패턴 숙지**: GoF 디자인 패턴, SOLID 원칙
2. **마이크로서비스 패턴**: Saga, Circuit Breaker, API Gateway
3. **프론트엔드 패턴**: Hooks, Context, Suspense
4. **클라우드 패턴**: Kubernetes 기반 패턴들
5. **도메인 주도 설계(DDD)**: Repository, Aggregate, Value Object

---

## 참고 자료

### 기본 자료
- 플레이코드(JavaScript 테스팅): https://playcode.io/new/
- 코딩그라운드(Java 테스팅): https://www.tutorialspoint.com/compile_java_online.php
- 예제 소스 코드: https://github.com/wnghdcjfe/csnote

### 추가 학습 자료
- Microsoft Azure Architecture Patterns: https://docs.microsoft.com/en-us/azure/architecture/patterns/
- AWS Prescriptive Guidance: https://docs.aws.amazon.com/prescriptive-guidance/
- Martin Fowler's Blog: https://martinfowler.com/
- patterns.dev (Modern Web Patterns): https://www.patterns.dev/
- Refactoring Guru: https://refactoring.guru/design-patterns
- Microservices.io: https://microservices.io/patterns/

### 오픈소스 예제
- NestJS (Backend Framework with DI, Repository): https://nestjs.com/
- Redux Toolkit (State Management): https://redux-toolkit.js.org/
- React Query (Data Fetching): https://tanstack.com/query/
- Temporal (Workflow Engine for Saga): https://temporal.io/
