# 07 데이터 암호화
* 데이터 암호화 여부는 보안 감사에서 필수적으로 언급되는 부분이다.
* 핀테크 서비스처럼 중요한 정보를 저장하는 서비스에서는 응용 프로그램에서 암호화한 데이터를 데이터베이스 서버에서 다시 암호화하는 이중 암호화 방법을 선택하기도 한다.
* 응용 프로그램 암호화는 주로 중요 정보를 가진 칼럼 단위로 암호화를 수행하고 데이터베이스 수준에서는 테이블 단위로 암호화를 적용한다.

## 7.1 MySQL 서버의 데이터 암호화
* MySQL 서버의 암호화 기능은 데이터베이스 서보와 디스크 사이의 데이터 읽고 쓰기 지점에서 암호화 또는 복호화를 수행한다.
    * 그래서 MySQL 서버에서 디스크 입출력 이외의 부분에서는 암호화 처리가 전혀 필요치 않다.
    * 즉 MySQL 서버(InnoDB 스토리지 엔진)의 I/O 레이어에서만 데이터 암호화 및 복호화 과정이 실행되는 것이다.
    * MySQL 서버는 사용자의 쿼리를 처리하는 과정에서 테이블의 데이터가 암호화돼 있는지 여부를 식별할 필요가 없고, 암호화된 테이블 그냥 테이블과 동일한 처리 과정을 거친다.
    * 데이터 암호화 기능이 활성화 되있어도 MySQL 내부와 사용자 입장에서는 아무런 차이가 없다.
      * 이러한 암호화 방식을 이러한 암호화 방식을 TDE(Transparent Data Encryption) 또는 Data at Rest Encryption 이라고 한다.
        * Data at Rest는 메모리나 네트워크 전송 단계가 아닌 디스크에 저장된 단계에서만 암호화된다는 의미

<img src="./그림 7.1.png">

### 7.1.1 2단계 키 관리
* MySQL 서버의 TDE에서 암호화 키는 키링(KeyRing) 플러그인에 의해 관리된다.
* 다양한 키링 플러그인이 제공되지만 마스터 키를 관리하는 방법만 다를 뿐 MySQL 서버 내부적으로 작동하는 방식은 모두 동일하다.
  * keyring_file File-Based 플러그인(커뮤니티 에디션은 이것만 사용 가능)
  * keyring_encrypted_file Keyring 플러그인
  * keyring_okv KMIP 플러그인
  * keyring_aws Amazon Web Services Keyring 플러그인
* MySQL 서버의 키링 플러그인은 2단계 (2-Tier) 키 관리 방식을 사용한다.
* MySQL 서버에서는 두 가지 키로 암호화를 한다.
  * 마스터 키
  * 테이블 스페이스 키(프라이빗 키)

<img src="./그림 7.2.png">

* 암호화 아키텍처의 절차는 다음과 같다.
  * 1. 디스크의 파일(keyring_file, keyring_encrypted_file)에서 마스터 키를 가져온다.
  * 2. 암호화된 테이블이 생성될 때마다 해당 테이블을 위한 테이블 스페이스 키를 발급한다.
  * 3. 마스터 키를 이용해서 테이블 스페이스 키를 암호화해서 각 테이블의 데이터파일 헤더에 저장한다.(생성된 테이블 스페이스 키는 삭제되지 않는 이상 절대 변경 X)
* 마스터 키는 외부의 파일이기에 노출 가능성이 있어서 주기적으로 변경해야 한다.
```
mysql> ALTER INSTANCE ROTATE INNODB MASTER KEY; -- 마스터 키 변경 쿼리
```
* 마스터 키를 변경하면 MySQL 서버는 기존의 마스터 키를 이용해 각 테이블의 테이블 스페이스 키를 복호화한 다음 다시 새로운 마스터 키로 암호화하는데 이때 테이블 스페이스 키 자체와 데이터 파일의 데이터는 전혀 변경되지 않는다.
* 2단계 암호화를 사용하는 이유는 암호화 키 변경으로 인한 과도한 시스템 부하를 막기 위해서인데 테이블 스페이스 키가 변경된다면 데이터 파일의 모든 데이터를 다시 복호화 후 암호화 해야해서 엄청난 작업을 해야하며, 사용자 쿼리를 처리하는데도 영향을 미친다.
* MySQL 서버의 TDE에서 지원하는 암호화 알고리즘은 AES 256비트이며, 이외의 알고리즘은 지원되지 않는다.
  * 테이블 스페이스 키는 AES-256 ECB, 실제 파일은 AES-256 CBC 사용

### 7.1.2 암호화와 성능
* TDE 방식이므로 디스크로부터 한 번 읽은 데이터 페이지는 복호화되어 InnoDB의 버퍼 풀에 적재된다.
* 데이터 페이지가 한 번 메모리에 적재되면 암호화되지 않은 테이블과 동일한 성능을 보인다.
* InnoDB 버퍼 풀에 존재하지 않는 데이터 페이지를 읽어야 하는 경우, 복호화 과정을 거치므로 복호화 시간동안 지연된다.
* 암호화된 테이블이 변경되면 다시 디스크로 동기화될 때 다시 암호화돼야 하기에 시간이 더 걸리지만 백그라운드 스레드가 수행하기 때문에 사용자 쿼리가 지연되지는 않는다.
* SELECT, UPDATE, DELETE 명령은 변경하고자 하는 레코드를 InnoDB 버퍼 풀로 읽어와야 하기 때문에 디스크에서 읽어야 하는 데이터 페이지 개수에 따라서 복호화 지연이 발생된다.
* TDE를 적용한다 해도 데이터 파일의 크기는 암호화되지 않은 테이블과 동일하다. 암호화한다고 해서 InnoDB 버퍼 풀의 효율이 달라지거나, 메모리 사용 효율이 떨이지진 않는다.
* 한 테이블에 대해 암호화와 압축이 동시에 적용된다면, 압축을 먼저 실행하고 암호화를 한다.
  * 암호화된 결과문은 랜덤 바이트열을 가지며 압축률을 떨어뜨리기 때문에 압축 효율을 높이기 위해 압축을 먼저 실행한다. 
  * 암호화된 테이블의 데이터 페이지는 복호화된 상태로 InnoDB 버퍼 풀에 저장되지만 압축된 데이터 페이지는 압축, 압축 해제의 모든 상태로 InnoDB 버퍼 풀에 존재하는데 암호화가 먼저된다면 InnoDB 버퍼 풀에 존재하는 모든 데이터 페이지를 암호화해야 하기 때문이다.

### 7.1.3 암호화와 복제
* MySQL 서버의 복제에서 레플리카 서버는 소스 서버의 모든 사용자 데이터를 동기화하기 때문에 실제 데이터 파일도 동일할 것이라 생각할 수 있지만 TDE를 이용한 암호화 사용 시 마스터 키와 테이블 스페이스 키는 그렇지 않다.
* 모든 노드는 각자의 마스터 키를 할당해야 한다. 소스 서버와 레플리카 서버는 서로 다른 마스터 키를 갖도록 설정해야 한다.
* 소스 서버와 레플리카 서버는 서로 각자의 마스터 키와 테이블 스페이스 키를 관리하기 때문에 복제 멤버들의 데이터 파일은 암호화되기 전의 값이 동일하더라도 실제 암호화된 데이터가 저장된 데이터 파일의 내용은 완전히 달라진다.
* 마스터키는 변경될 수 있고, 마스터 키를 변경하면 소스 서버와 레플리카 서버 둘다 각자 마스터키가 생성되는데 백업에서 키링 파일을 백업해야 데이터를 복구할 수 있다.

## 7.2 keyring_file 플러그인 설치
* TDE의 암호화 키 관리는 플러그인 방식으로 제공된다.
* 엔터프라이즈 에디션은 플러그인이 다양하지만 커뮤니티 에디션은 keyring_file만 가능하다.
* keyring_file은 마스터 키를 디스크 파일로 관리하고, 평문으로 디스크에 저장된다.
  * 파일이 외부에 노출 시 암호화는 무용지물이다.
* TDE는 시작 단계에서 가장먼저 초기화돼야 하고, 저장 파일 경로를 명시하면 된다.
```
-- my.cnf에 설정
early-plugin-load = keyring_file.so
keyring_file_data = /very/secure/directory/tde_master.key
```
```
-- 명령어를 통해서 확인
mysql> SHOW PLUGINS;
```

## 7.3 테이블 암호화
어떤 키링 플러그인을 사용하든 관계없이 암호화된 테이블을 생성하고 활용하는 방법은 동일하다.

### 7.3.1 테이블 암호화
* TDE를 이용하는 테이블이 일반적인 테이블 생성 구문과 동일하고 `ENCRYPTION='Y'` 옵션만 추가로 넣어주면 된다.
  * 옵션을 추가하면 테이블 데이터가 디스크에 기록될 때 자동으로 암호화 후 저장되고, 디스크에서 메모리로 읽어올 때 복호화된다.
```
mysql> CREATE TABLE tab_encrypted ( 
    id INT,
    data VARCHAR(100),
    PRIMARY KEY(id)
  ) ENCRYPTION='Y';
```
* `default_table_encryption` 시스템 변수를 통해서 옵션 지정없이 암호화된 테이블로 생성 가능하다.

### 7.3.2 응용 프로그램 암호화의 비교
* 보통 민감정보와 같은 데이터는 응용 프로그램에서 암호화한 후 DB서버에 저장하는 경우가 있는데 이런 경우 암호화된 값인지 MySQL 서버는 인지할 수 없다.
* 응용 프로그램에서 암호화된 컬럼은 인덱스를 생성해도 인덱스의 기능을 100% 활용할 수 없다.
  * 예를 들면 이미 암호화된 데이터이기 때문에 특정 조건을 기준으로 정렬해서 상위 10개만 가져오는 등의 쿼리는 사용할 수 없다.
* 범위 검색이나 정렬을 할려면 직접 암호화하지 않고 암호화 기능(TDE)를 사용하면 인덱스 작업을 처리한 후 디스크에 저장할 때만 암호화하기 때문에 제약이 없다.
* 응용 프로그램의 암호화와 MySQL 서버의 암호화 기능 중 선택해야 하는 상황이면 MySQL 서버의 암호화 기능을 선택하는 것이 낫다.
* MySQL 서버의 TDE 기능으로 암호화하면 실행 중인 MySQL 서버에 로그인할 수 있다면 모든 데이터를 평문으로 확인할 수 있지만 응용 프로그램 암호화는 MySQL 서버에 로그인해도 평문의 내용을 확인할 수 없다.
* 요건과 성능을 고려해서 적합한 암호화를 선택하던지 혼합해서 사용하면 된다.

### 7.3.3 테이블스페이스 이동
* 테이블을 다른 서버로 복사해야 하는 경우 또는 특정 테이블의 데이터 파일만 백업했다가 복구하는 경우라면 테이블스페이스 이동(Export & Import) 기능이 레코드를 덤프했다가 복구하는 방식보다 훨씬 효율적이고 빠르다.
* TDE가 적용되서 암호화된 테이블은 명령어를 사용해서 테이블스페이스를 익스포트할 수 있다.
  ```
  mysql> FLUSH TABLES source_table FOR EXPORT;
  ```
  * 기본 테이블에 명령어 실행시 동작
    * source_table의 저장되지 않은 변경 사항을 모두 디스크로 기록하고，더이상 source_table에 접근할 수 없게 잠금하고 동시에 source_table의 구조를 source, table.cfg 파일로 기록
    * source_table.ibd 파일과 source_table.cfg 파일을 목적지 서버로 복사 후 완료되면 UNLOCK TABLES 명령을 실행해 source_table을 사용할 수 있게 변경
  * TDE로 암호화된 테이블에 명령어 실행시 동작 
    * 명령어를 실행하면 MySQL 서버는 임시로 사용할 마스터 키를 발급해서 source_table.cfp라는 파일로 기록한다.
    * 그리고 암호화된 테이블스페이스 키를 기존 마스터 키로 복호화한 후, 임시로 발급한 마스터 키를 이용해 다시 암호화해서 데이터 파일 헤더 부분에 저장한다.
    * 그래서 암호화된 테이블은 테이블스페이스 이동 기능을 사용할 때는 반드시 데이터 파일과 임시 마스터 키가 저장된 *.cfp 파일을 함꼐 복사해야 한다.

## 7.4 언두 로그 및 리두 로그 암호화
테이블 암호화는 일단 하나에 대해 암호화가 적용되면 해당 테이블의 모든 데이터가 암호화해야 하지만 언두 로그나 리두 로그는 적용할 수가 없다.<br>
실행 중인 MySQL 서버에서 언두 로그나 리두 로그를 활성화한다해도 모든 리두 로그나 언두 로그의 데이터를 해당 시점에 한 번에 암호화해서 다시 저장할 수 없다.<br>
암호화가 활성화되면 그때부터 생성되는 언두 로그나 리두 로그만 암호화해서 저장하고, 반대로 비활성화되면 평문으로 저장한다.<br>

언두 로그, 리두 로그 모두 각각의 테이블스페이스 키로 저장되고, 테이블스페이스 키는 마스터 키로 암호화된다.<br>
여기서 말하는 테이블스페이스 키는 테이블 암호화에 사용된 테이블스페이스 키가 아닌 언두 로그, 리두 로그 파일을 위한 프라이빗 키를 의미한다.<br>
리두 로그와 언두 로그를 위한 각각의 프라이빗 키가 발급되고, 해당 프라이빗 키는 마스터 키로 암호화되어 리두 로그 파일과 언두 로그 파일의 헤더에 저장된다.<br>

## 7.5 바이너리 로그 암호화
테이블 암호화가 적용돼도 바이너리 로그, 릴레이 로그 파일도 리두 로그, 언두 로그처럼 평문을 저장하는데 언두 로그, 리두 로그는 짧은 시간 동안의 데이터만 가지기 때문에 보안에 민감하지 않을 수 있다.<br>
바이너리 로그는 상당히 긴 시간 동안 보관하는 경우도 존재하고, 증분 백업을 위해서 보관하기 때문에 암호화는 상황에 따라 중요할 수 있다.<br>

바이너리 로그, 릴레이 로그 파일 암호화 기능은 디스크에 저장된 로그 파일에 대한 암호화만 담당하고, MySQL 서버의 메모리 내부 또는 소스 서버와 레플리카 서버 간의 네트워크 구간에서 로그 데이터를 암호화하지 않는다.<br>
복제 멤버 간의 네트워크 구간에서도 바이너리 로그를 암호화하려면 MySQL 복제를 위한 계정이 SSL을 사용하도록 설정하면 된다.<br>

### 7.5.1 바이너리 로그 암호화 키 관리
* 바이너리 로그, 릴레이 로그 파일 데이터의 암호화는 2단계 암호화 키 관리 방식을 사용한다.
* 암호화 방식은 파일 키로 암호화해서 디스크에 저장하고, 파일 키는 바이너리 암호화 키로 암호화해서 로그 파일의 헤더에 저장한다.
* `바이너리 로그 암호화 키`는 테이블 암호화의 마스터 키와 동일한 역할을 한다.
* 파일 키는 바이너리 로그와 릴레이 로그 파일 단위로 자동으로 생성되어 해당 로그 파일의 데이터 암호화에만 사용된다.

<img src="./그림 7.3.png">

### 7.5.2 바이너리 로그 암호화 키 변경
* 바이너리 로그 암호화키는 명령어를 통해서 변경할 수 있다.
```
mysql> ALTER INSTANCE ROTATE BINLOG MASTER KEY;
```

### 바이너리 로그 암호화 키 변경 시 과정
1. 증가된 시퀀스 번호화 함께 새로운 바이너리 로그 암호화 키 발급 후 키링 파일에 저장
2. 바이너리 로그 파일과 릴레이 로그 파일 스위치(새로운 로그 파일로 로테이션)
3. 새로 생성되는 바이너리 로그와 릴레이 로그 파일의 암호화를 위해 파일 키를 생성하고, 파일 키는 바이너리 로그 파일 키(마스터 키)로 암호화해서 각 로그 파일에 저장
4. 기존 바이너리 로그와 릴레이 로그 파일의 파일 키를 읽어서 새로운 바이너리 로그 파일 키로 암호화해서 다시 저장
5. 모든 바이너리 로그와 릴레이 로그 파일이 새로운 바이너리 로그 암호화 키로 다시 암호화됐다면 기존 바이너리 로그 암호화 키를 키링 파일에서 제거

### 7.5.3 mysqlbinglog 도구 활용
* 바이너리 로그 암호화 키는 MySQL 서버만 가지고 있어서 바이너리 로그 파일을 외부에서 복호화가 불가능하다.
* 암호화된 바이너리 로그 파일의 내용을 볼 수 있는 방법은 MySQL 서버를 통해 가져오는 방법이 유일하다.
* mysqlbinlog 명령을 실행할 때 `--read-from-remote-server` 파라미터와 함께 접속 정보를 입력한다.