# 09. 옵티마이저와 힌트
MySQL 서버로 요청된 쿼리는 결과는 동일하지만 내부적으로 결과를 만들어내는 방법은 매우 다양하다.<br>
MySQL 서버에서는 쿼리를 최적으로 실행하기 위해서 통계 정보를 참조하며, 기본 데이터를 비교해 최적의 실행 계획을 수립하는 작업을 `옵티마이저`가 한다.<br>
쿼리는 실행 계획을 확인할 수 있는데 실행 계획을 이해하려면 옵티마이저가 실행하는 최적화에 대해 지식을 갖추고 있어야 한다.<br>

## 9.1 개요
옵티마이저가 수립하는 실행 계획을 이해해야 불합리한 부분을 찾아서 최적화된 방법으로 실행 계획을 수립하도록 유도할 수 있다.

### 9.1.1 쿼리 실행 절차
* MySQL에서 쿼리 실행되는 과정은 세 단계로 나눌 수 있다.
    1. 사용자로부터 요청된 SQL 문장을 잘게 쪼개서 MySQL 서버가 이해할 수 있는 수준으로 분리(파스 트리)한다.
        * `SQL 파싱`이라고 하며, SQL 파서 모듈로 SQL 문장을 분석하고 파스 트리를 만들고 이를 이용해 쿼리를 실행한다.
        * SQL 문장의 문법적 오류를 처리한다.
    2. SQL의 파싱 장보(파스 트리) 확인하면서 어떤 테이블부터 읽고 어떤 인덱스를 이용해 테이블을 읽을지 선택한다.
        * `최적화 및 실행 계획 수립`이라고 하며, SQL 파스 트리를 참조해 테이블과 인덱스를 어떤 식으로 읽을지를 선택한다.
          * 불필요한 조건 제거 및 복잡한 연산의 단순화
          * 여러 테이블의 조인이 있는 경우 어떤 순서로 테이블을 읽을지 결정
          * 각 테이블에 사용된 조건과 인덱스 통계 정보를 이용해 사용할 인덱스를 결정 
          * 가져온 레코드들을 임시 테이블에 넣고 다시 한번 가공해야 하는지 결정
        * 옵티마이저에서 처리하고 완료 시 실행 계획이 만들어진다.
    3. 두 번째 단계에서 결정된 테이블의 읽기 순서나 선택된 인덱스를 이용해 스토리지 엔진으로부터 데이터를 가져온다.
        * 수립된 실행계획에 따라 스토리지 엔진에 레코드를 읽어오도록 요청한다.
        * MySQL 엔진에서 스토리지 엔진으로부터 받은 레코드를 조인하거나 정렬하는 작업을 수행한다.
* 1, 2단계는 MySQL엔진이, 3단계는 MySQL엔진과 스토리지 엔진이 동시에 참여한다.

### 9.1.2 옵티마이저의 종류
* 옵티마이저는 두뇌와 같은 역할을 담당하고 2가지 종류로 나눌 수 있다.
  * 비용 기반 최적화 방법
    * 각 단위 작업의 비용 정보와 대상 테이블의 예측된 통계 정보를 이용해 실행 계획별 비용을 산출한다.
    * 비용이 최소로 소용되는 방식을 선택해 쿼리를 실행한다.
  * 규칙 기반 최적화 방법
    * 옵티마이저에 내장된 우선순위에 따라 실행 계획을 수립하는 방식이다.
    * 통계 정보를 조사하지 않고 실행 계획이 수립되서 항상 같은 실행 방법을 만들지만 이런 이유로 좋지 않고, 거의 사용되지 않는다.

## 9.2 기본 데이터 처리
MySQL 서버를 포함한 모든 RDBMS는 데이터를 정렬하거나 그루핑하는 등의 기본 데이터 가공 기능을 가지고 있다.<br>

### 9.2.1 풀 테이블 스캔과 풀 인덱스 스캔
* 풀 테이블 스캔
  * 인덱스를 사용하지 않고 테이블의 데이터를 처음부터 끝까지 읽어서 요청된 작업을 처리하는 작업이다.
* 풀 인덱스 스캔
  * 인덱스의 리프 노드를 연결하는 링크드 리스트르 따라서 처음부터 끝까지 스캔하는 방식이다.
* 일반적으로 테이블 전체 크기는 인덱스보다 크기 때문에 테이블을 처음부터 끝까지 읽는 작업은 상당히 많은 디스크 읽기가 필요하다.
* InnoDB 스토리지 엔진은 특정 테이블의 연속된 데이터 페이지가 읽히면 백그라운드 스레드에 의해 `리드 어헤드` 작업이 자동으로 시작된다.
  * `리드 어헤드`는 어떤 영역의 데이터가 앞으로 필요해지리라는 것을 예측해서 요청이 오기 전에 미리 디스크에서 읽어 InnoDB 버퍼 풀에 가져다 두는 것을 의미한다.
* 포그라운드 스레드는 미리 버퍼 풀에 준비된 데이터를 가져다 사용하기만 하면 되므로 쿼리가 상당히 빨리 처리된다.
* 리드 어헤드는 풀 인덱스 스캔에도 동일하게 사용된다.

### 9.2.2 병렬 처리
* 하나의 쿼리를 여러 스레드가 작업을 나누어 동시에 처리한다는 것을 의미한다.
* MySQL 8.0에서는 `innodb_parallel_read_threads`라는 시스템 변수를 이용해 하나의 쿼리를 최대 몇 개의 스레드를 이용해서 처리할지 설정할 수 있다.
```
mysql> SET SESSION innodb_parallel_read_threads=1;
```
* MySQL 8.0에서는 아무런 조건 없이 단순히 테이블의 전체 건수를 가져오는 쿼리만 병렬로 처리할 수 있다. 
```
mysql> SELECT COUNT(*) FROM employees;
```
* 병렬 처리용 스레드 개수를 CPU 코어 개수보다 크게 설정하면 성능이 떨어질 수도 있어서 주의해야한다.

### 9.2.3 ORDER BY 처리(Using filesort)
* 정렬은 보통 필수적으로 사용하고 조회 쿼리에 포함해서 사용한다.
* 정렬을 처리하는 방법은 두 가지 방법으로 나눌 수 있다.
  * 인덱스를 이용하는 방법
  * 쿼리가 실행될 때 "Filesort"라는 별도의 처리를 이용하는 방법

<table>
    <colgroup>
        <col width="20%">
        <col width="40%">
        <col width="40%">
    </colgroup>
    <tr>
        <th></th>
        <th>장점</th>
        <th>단점</th>
    </tr>
    <tr>
        <th>인덱스 이용</th>
        <td>
            이미 정렬돼 있어서 읽기만 하면 되서 매우 빠르다.
        </td>
        <td>
            INSERT, UPDATE, DELETE 작업 시 추가 작업으로 느리며, 인덱스를 따로 저장하기 때문에 디스크 공간과 버퍼 풀에 적재할 메모리가 많이 필요하다.
        </td>
    </tr>
    <tr>
        <th>Filesort 이용</th>
        <td>
            인덱스를 사용할 때의 단점이 장점이 되며, 대상 레코드가 많지 않으면 메모리에서 Filesort 처리가 되서 빠르다.
        </td>
        <td>
            대상 레코드가 많아질수록 쿼리의 응답 속도가 느리다.
        </td>
    </tr>
</table>

* 모든 정렬을 Filesort로 작업을 해야하는 것은 아니지만 크게 4가지 이유로 모든 정렬을 인덱스로 튜닝하기는 불가능하다.
  * 정렬 기준이 너무 많아서 요건별로 모두 인덱스를 생성하는 것이 불가능한 경우
  * GROUP BY의 결과 또는 DISTINCT 같은 처리의 결과를 정렬해야 하는 경우
  * UNION의 결과와 같이 임시 테이블의 결과를 다시 정렬해야 하는 경우
  * 랜덤하게 결과 레코드를 가져와야 하는 경우
* MySQL 서버에서 인덱스를 이용하지 않고 별도의 정렬 처리를 수행했는지는 실행 계획의 EXTRA 칼럼에 `Using filesort` 메시지 여부로 판단할 수 있다.

#### 9.2.3.1 소트 버퍼
* MySQL은 정렬을 수행하기 위해 `소트 버퍼(Sort buffer)`라는 별도의 메모리 공간을 할당받아 사용한다.
* 소트 버퍼는 정렬이 필요한 경우에만 할당되는데 버퍼의 크기가 레코드의 크기에 따라 가변적으로 변하며 쿼리 실행이 완료되면 메모리 공간은 즉시 반납된다.
```
-- 설정 파일(my.ini , my.cnf)에서 시스템 변수로 설정
sort_buffer_size=1M
-- 설정 명령어
mysql> SET GLOBAL sort_buffer_size = 4024024;
-- 확인 명령어
mysql> show GLOBAL variables like "sort_buffer_size";
```

* 정렬해야 할 레코드가 소트 버퍼로 할당된 메모리 공간보다 크다면 레코드로 여러 조각으로 나눠서 처리하는데, 임시 저장을 위해 디스크를 사용한다.
* 메모리의 소트 버퍼에서 정렬을 수행하고 임시로 디스크에 기록한 후 레코드를 다시 가져와서 정령, 저장을 반복 후 레코드를 병합하면서 정렬한다.
* 소트 버퍼를 크게 설정하면 더 빨라질 것 같지만 실제로는 큰 차이가 없는데 큰 메모리 공간을 할당하면 성능이 감소되기 떄문이다. 
* 소트 버퍼는 세션 메모리 영역으로 클라이언트마다 할당되는 공간이 아니라 커넥션이 많을수록 그만큼 작업 공간이 커지고 메모리 부족 현상을 겪을 수도 있고 운영체제가 프로세스를 강제로 종료할 수도 있다.

#### 9.2.3.2 정렬 알고리즘
* 레코드 정렬할 때, 레코드 전체를 소트 버퍼에 담을지 또는 정렬 기준 칼럼만 소트 버퍼에 담을지에 따라 2가지 정렬 모드가 있다.
  * 싱글 패스(Single-pass)
  * 투 패스(Two-pass)
* 정렬을 수행하는 쿼리가 어떤 정렬 모드를 사용하는지는 옵티마이저 트레이스 기능으로 확인 가능하다.
* `최신 버전에서는 일반적으로 싱글 패스 정렬 방식을 주로 사용`하지만, 아래의 경우에는 싱글 패스 정렬 방식을 사용하지 못하고, 투패스 정렬 방식을 사용한다.
  * 레코드의 크기가 max_length_for_sort_data 시스템 변수에 설정된 값보다 클 때
  * BLOB이나 TEXT 타입의 칼럼이 SELECT 대상에 포함할 때
* 싱글 패스 방식은 정렬 대상 레코드 건수가 작은 경우 빠른 성능을 투 패스 방식은 정렬 대상 레코드의 크기나 건수가 상당히 많은 경우 효율적이다.

##### 싱글 패스 정렬 방식
* 소트 버퍼에 `정렬 기준(ORDER BY)` 칼럼을 포함해 `SELECT 대상이 되는 칼럼 전부`를 담아서 정렬을 수행하는 방식이다.
* 처음 employees 테이블을 읽을 때 `정렬에 필요하지 않은 last_name 칼럼까지 전부 읽어서 소트 버퍼에 담고 정렬을 수행`한 뒤, 정렬 버퍼의 내용을 그대로 클라이언트로 넘겨주는 과정을 볼 수 있다.
```
mysql> SELECT emp_no, first_name, last_name
       FROM employees
       ORDER BY first_name;
```

<img src="./그림 9.2.png">

##### 투 패스 정렬 방식
* `정렬 대상 칼럼과 프라이머리 키 값만 소트 버퍼에 담아서 정렬을 수행`하고, `정렬된 순서대로 다시 프라이머리 키로 테이블을 읽어서 SELECT한 칼럼을 가져오는` 정렬 방식으로, 싱글 패스 정렬 방식이 도입되기 이전부터 사용하던 방식이다.
* 투 패스 정렬 방식은 처음 employees 테이블을 읽을 때는 `정렬에 필요한 first_name 칼럼과 프라이머리 키인 emp_no만 읽어서 정렬`을 수행하고, employees `테이블을 한 번 더 읽어서` last_name을 가져온 뒤, 최종적으로 그 결과를 클라이언트 쪽으로 넘기는 과정을 확인할 수 있다.
```
mysql> SELECT emp_no, first_name, last_name
       FROM employees
       ORDER BY first_name;
```

<img src="./그림 9.3.png">

#### 9.2.3.3 정렬 처리 방법
* 쿼리에 `ORDER BY가 사용되면 반드시 다음 3가지 처리 방법 중 하나`로 정렬이 처리된다. 일반적으로 밑으로 갈수록 처리 속도는 떨어진다.
<table>
    <colgroup>
        <col width="50%">
        <col width="50%">
    </colgroup>
    <tr>
        <th>정렬 처리 방법</th>
        <th>실행 계획의 Extra 컬럼 내용</th>
    </tr>
    <tr>
        <th>인덱스를 사용한 정렬</th>
        <td>
            별도 표기 없음
        </td>
    </tr>
    <tr>
        <th>조인에서 드라이빙 테이블만 정렬</th>
        <td>
            "Using filesort" 메시지가 표시됨
        </td>
    </tr>
    <tr>
        <th>조인에서 조인 결과를 임시 테이블로 저장 후 정렬</th>
        <td>
            "Using temporary; Using filesort" 메시지가 표시됨
        </td>
    </tr>
</table>

* 옵티마이저가 `인덱스를 이용할 수 있다면 별도의 "Filesort" 과정 없이 인덱스를 순서대로 읽어서 결과를 반환`하지만, `인덱스를 사용할 수 없다면 WHERE 조건에 일치하는 레코드를 검색해 정렬 버퍼에 저장하면서 정렬을 처리(Filesort)`한다.
* 이때 옵티마이저는 정렬 대상 레코드를 최소화하기 위해 아래 2가지 방법 중 하나를 선택한다.
  * 조인의 드라이빙 테이블만 정렬한 다음 조인을 수행
    * `드라이빙 테이블`: 조인 시 먼저 액세스되는 테이블이다.
    * `드리븐 테이블`: 조인 시 나중에 액세스되는 테이블이다.
  * 조인이 끝나고 일치하는 레코드를 모두 가져온 후 정렬을 수행
* 보통 조인이 수행되면서 레코드 건수와 레코드의 크기는 거의 배수로 불어나기 때문에 가능하다면 드라이빙 테이블만 정렬한 다음 조인을 수행하는 방법이 효율적이다.

##### 인덱스를 이용한 정렬
* 인덱스를 이용한 정렬을 위해서는 `반드시 ORDER BY에 명시된 칼럼이 제일 먼저 읽는 테이블(조인이 사용된 경우 드라이빙 테이블)에 속하고, ORDER BY의 순서대로 생성된 인덱스가 있어야 한다.`
* `WHERE 절에 첫 번째로 읽는 테이블의 칼럼에 대한 조건이 있다면, 그 조건과 ORDER BY는 같은 인덱스를 사용`할 수 있어야 한다.
* 인덱스를 이용해 정렬이 처리되는 경우에는 실제 인덱스의 값이 정렬돼 있기 때문에 인덱스의 순서대로 읽기만 하면 된다. 
```
mysql> SELECT *
              FROM employees e, salaries s
              WHERE s.emp_no=e.emp_no
                AND e.emp_no BETWEEN 100002 AND 100020
              ORDER BY e.emp_no;

-- // emp_no 칼럼으로 정렬이 필요한데, 인덱스를 사용하면서 자동으로 정렬이 된다고
-- // 일부러 ORDER BY emp_no를 제거하는 것은 좋지 않은 선택이다.
mysql> SELECT *
              FROM employees e, salaries s
              WHERE s.emp_no=e.emp_no
                AND e.emp_no BETWEEN 100002 AND 100020;
```
* 인덱스를 사용한 정렬이 가능한 이유는 B-Tree 인덱스가 키 값으로 정렬돼 있기 때문이다. 또한 조인이 네스티드-루프 방식으로 실행되기 때문에 조인 때문에 드라이빙 테이블의 인덱스 읽기 순서가 흐트러지지 않는다.
  * `네스티드-루프`: 선행테이블(Driving Table)의 처리범위를 하나씩 액세스하면서 그 추출된 값으로 연결할 테이블을 조인하는 방식
* 조인이 사용된 쿼리의 실행 계획에 조인 버퍼가 사용되면 순서가 흐트러질 수 있기 때문에 주의해야 한다.
  * `조인 버퍼(Join Buffer)`: 조인 시 어떤 방식으로도 드리븐 테이블의 풀 테이블 스캔이나 인덱스 풀 스캔을 피할 수 없다면 옵티마이저는 드라이빙 테이블에서 읽은 레코드를 메모리에 캐시 한 후 드린 테이블과 이 메모리 캐시를 조인하는 형태로 처리하는데 이때 사용되는 메모리의 캐시를 의미한다.

##### 조인의 드라이빙 테이블만 정렬
* 조인이 수행되서 레코드의 건수가 많아진다면 조인을 실행하기 전 드라이빙 테이블을 먼저 정렬한 다음 조인을 실행하는 것이 차선책이다.
* 이 방법으로 정렬이 처리되려면 조인에서 `첫 번째로 읽히는 테이블(드라이빙 테이블)의 칼럼만으로 ORDER BY 절을 작성`해야 한다.
```
mysql> SELECT *
        FROM employees e, salaries s
        WHERE s.emp_no=e.emp_no
            AND e.emp_no BETWEEN 100002 AND 100010
        ORDER BY e.last_name;
```
* WHERE 절이 다음 2가지 조건을 갖추고 있기 때문에 옵티마이저는 employees 테이블을 드라이빙 테이블로 선택할 것이다.
  * WHERE 절의 검색 조건("emp_no BETWEEN 100002 AND 100010")은 employees 테이블의 프라이머리 키를 이용해 검색하면 작업량을 줄일 수 있다.
  * 드리븐 테이블(salaries)의 조건 칼럼인 emp_no 칼럼에 인덱스가 있다.

<img src="./그림 9.5.png">

##### 임시 테이블을 이용한 정렬
쿼리가 여러 테이블을 조인하지 않고, 하나의 테이블로부터 SELECT해서 정렬하는 경우라면 임시 테이블이 필요하지 않지만 2개 이상의 테이블을 조인해서 그 결과를 정렬해야 한다면 임시 테이블이 필요할 수도 있다.

위에서 살펴본 "조인의 드라이빙 테이블만 정렬"은 2개 이상의 테이블이 조인되면서 정렬이 실행되지만 임시 테이블을 사용하지 않는다. 하지만 `그 외 패턴의 쿼리에서는 항상 조인의 결과를 임시 테이블에 저장하고, 그 결과를 다시 정렬`하는 과정을 거친다. 이 방법은 정렬의 3가지 방법 가운데 `정렬해야 할 레코드 건수가 가장 많기 때문에 가장 느린 정렬 방법`이다.

<img src="./그림 9.6.png">

##### 스트리밍 방식
서버 쪽에서 처리할 데이터양에 관계없이 조건에 일치하는 레코드가 검색될 때마다 바로바로 클라이언트로 전송해주는 방식이다.

클라이언트는 MySQL 서버가 일치하는 레코드를 찾는 즉시 전달받기 때문에 동시에 데이터 가공 작업을 시작할 수 있다.

LIMIT 조건을 추가하면 가져오는 레코드 건수가 줄어들기 때문에 마지막 레코드를 가져오기까의 시간을 줄일 수 있다.

##### 버퍼링 방식
ORDER BY나 GROUP BY 같은 쿼리는 정렬이나 그루핑이 필요해서 스트리밍 방식을 사용할 수 없고 `MySQL 서버가 레코드를 검색하고 작업하는 동안 클라이언트는 대기해야하므로 응답 속도가 느려진다.`

버퍼링 방식으로 처리되는 쿼리는 먼저 결과를 모아서 MySQL 서버에서 일괄 가공 후 모든 결과를 스토리지 엔진으로부터 가져올 때 까지 기다리기 때문에 LIMIT를 써도 성능에 도움이 되지 않는다.

---

ORDER BY의 3가지 처리 방법 가운데 `인덱스를 사용한 정렬 방식만 스트리밍 형태의 처리`이며 나머지는 모두 버퍼링된 후 정렬된다.

정렬 방식으로 처리되는지에 따라서 큰 성능 차이를 만들고 `가능하면 인덱스를 사용한 정렬로 유도하고 최소한 드라이빙 테이블만 정렬해도 되는 수준으로 유도하는 것이 좋은 튜닝 방법`이다.

#### 9.2.3.4 정렬 관련 상태 변수
* MySQL 서버는 작업의 실행 횟수를 상태 변수로 저장하는데, 이 값들들 이용해 MySQL 서버가 처리한 정렬 작업의 내용을 이해할 수 있다.
  * `Sort_merge_passes`: 멀티 머지 처리 횟수
  * `Sort_range`: 인덱스 레인지 스캔을 통해 검색된 결과에 대한 정렬 작업 횟수
  * `Sort_scan`: 풀 테이블 스캔을 통해 결색된 결과에 대한 정렬 작업 횟수
  * `Sort_rows`: 지금까지 정렬한 전체 레코드 건수

### 9.2.4 GROUP BY 처리
* GROUP BY도 쿼리가 스트리밍된 처리를 할 수 없게 하는 처리이다.
* GROUP BY의 HAVING 절에서 사용된 조건은 인덱스를 사용할 수 없어서 인덱스로 튜닝이 불가능하다.
* GROUP BY에서는 인덱스를 사용하는 할 때는 인덱스 스캔, 루스 인덱스 스캔이 존재하고 사용하지 않을 때는 임시 테이블을 사용한다.

#### 9.2.4.1 인덱스 스캔을 이용하는 GROUP BY(타이트 인덱스 스캔)
* 조인의 드라이빙 테이블에 속한 칼럼만 이용해 그루핑할 때 GROUP BY 칼럼으로 이미 인덱스가 있다면 그 인덱스를 차례대로 읽으면서 그루핑 작업을 수행하고 그 결과로 조인을 처리한다.
* 그룹 함수 등의 그룹 값을 처리해야 할 때는 임시 테이블이 필요할 때도 있다.

#### 9.2.4.2 루스 인덱스 스캔을 이용하는 GROUP BY
* 옵티마이저가 루스 인덱스 스캔을 사용할 때는 실행 계획의 Extra 칼럼에 "Using index for group-by" 코멘트가 표시된다.
* 루스 인덱스 스캔 방식은 단일 테이블에 대해 수행되는 GROUP BY 처리에만 사용할 수 있다. 프리픽스 인덱스는 이 방식을 사용할 수 없다.
* 루스 인덱스 스캔은 인덱스의 유니크한 값의 수가 적을수록 성능이 향상된다.(분포도가 좋지 않은 인덱스일수록 성능이 향상된다)
```
-- 루스 인덱스 스캔을 사용할 수 없는 쿼리 패턴

-- // MIN()과 MAX() 이외의 집합 함수가 사용됐기 때문에 루스 인덱스 스캔은 사용 불가
SELECT coll, SUM(col2) FROM tb_test GROUP BY col1;

-- // GROUP BY에 사용된 칼럼이 인덱스 구성 칼럼의 왼쪽부터 일치하지 않기 때문에 사용 불가 
SELECT col1, col2 FROM tb_test GROUP BY col2, col3;

-- // SELECT 절의 칼럼이 GROUP BY와 일치하지 않기 때문에 사용 불가 
SELECT col1, col3 FROM tb_test GROUP BY col1, col2;
```

#### 9.2.4.3 임시 테이블을 사용하는 GROUP BY
* 인덱스를 전혀 사용하지 못할 때는 임시 테이블을 사용하는 GROUP BY 방식으로 처리된다.
* 8.0 버전부터는 ORDER BY 절이 없을 때, 묵시적 정렬이 실행되지 않는다.

### 9.2.5 DISTINCT 처리
* 유니크 값만 조회하려고 DISTINCT를 처리하는데 집합 함수와 함께 사용되는 경우와 집합 함수가 없는 경우에 따라서 DISTINCT가 미치는 범위가 달라진다.
* DISTINCT가 사용되는 쿼리에서 인덱스를 사용하지 못 할 때는 항상 임시 테이블이 필요하다.

#### 9.2.5.1 SELECT DISTINCT ...
* 단순히 유니크한 레코드만 가져오고자 한다면 GROUP BY와 동일한 방식으로 처리된다.
* DISTINCT는 SELECT하는 레코드를 유니크하게 SELECT하는 것이지, 특정 칼럼만 유니크하게 조회하는 것이 아니다.
```
-- // first_name, last_name 조합 전체가 유니크한 레코드를 가져온다.
mysql> SELECT DISTINCT first_name, last_name FROM employees;

-- // DISTINCT는 함수가 아니기 때문에 괄호에는 의미가 없다.
mysql> SELECT DISTINCT(first_name), last_name FROM employees;
```

#### 9.2.5.2 집합 함수와 함께 사용된 DISTINCT
* COUNT(), MIN(), MAX() 같은 집합 함수 내에서 DISTINCT 키워드가 사용될 수 있는데, 이 경우에는 SELECT DISTINCT …와 다른 형태로 해석된다.
* 집합 함수 내에서 사용된 DISTINCT는 그 집합 함수의 인자로 전달된 칼럼값이 유니크한 것들을 가져온다.
* 인덱스된 칼럼에 대해서 DISTINCT 처리를 수행하면 인덱스 풀 스캔, 인덱스 레인지 스캔하면서 임시 테이블 없이 최적화된 처리를 수행하지만 인덱스를 사용하지 않는다면 임시 테이블을 생성해 임시 테이블의 컬럼에 유니크 인덱스를 생성하기 때문에 레코드가 많다면 느려진다.

### 9.2.6 내부 임시 테이블 활용
* MySQL 엔진이 스토리지 엔진으로부터 받아온 레코드를 정렬하거나 그루핑할 때는 내부적인 임시 테이블을 사용한다.
* 내부적인 임시 테이블은 "CREATE TEMPORARY TABLE" 명령으로 만든 임시 테이블과는 다르다.
* 내부적인 임시 테이블은 쿼리 처리가 완료되면 자동으로 삭제된다.

#### 9.2.6.1 메모리 임시 테이블과 디스크 임시 테이블
* MySQL 8.0 버전부터는 메모리는 TempTable이라는 스토리지 엔진을 사용, 디스크에 저장되는 임시 테이블은 InnoDB 스토리지 엔진을 사용한다.
* `internal_tmp_mem_storage_engine` 시스템 변수를 이용해 메모리용 임시 테이블과 디스크 임시 테이블 중에서 선택할 수 있다.
* 메모리의 TempTable의 크기가 1GB를 넘으면 메모리의 임시 테이블을 디스크로 기록하는데 2가지 디스크 저장 방식 중 하나를 선택한다.
  * 메모리의 TempTable을 MMAP 파일로 기록
  * InnoDB 테이블로 기록
* MMAP 파일로 전환하는 것이 InnoDB 테이블로 전환하는 것보다 오버헤드가 적기 때문에 MMAP 파일로 전환하는 것이 기본값이다.

#### 9.2.6.2 임시 테이블이 필요한 쿼리
* 인덱스를 사용하지 못할 때는 내부 임시 테이블을 생성해야 할 때가 있다.
  * ORDER BY와 GROUP BY에 명시된 칼럼이 다른 쿼리
  * ORDER BY나 GROUP BY에 명시된 칼럼이 조인의 순서상 첫 번째 테이블이 아닌 쿼리
  * DISTINCT나 ORDER BY가 동시에 쿼리에 존재하는 경우 또는 DISTINCT가 인덱스로 처리되지 못하는 쿼리
  * UNION이나 UNION DISTINCT가 사용된 쿼리
  * 쿼리의 실행 계획에서 select_type이 DERIVED인 쿼리
* 일반적으로 유니크 인덱스가 있는 내부 임시 테이블은 그렇지 않은 쿼리보다 처리 성능이 상당히 느리다.

#### 9.2.6.3 임시 테이블이 디스크에 생성되는 경우
* 내부 임시 테이블은 기본적으로 메모리상에 만들어지지만 특정 조건에는 메모리 임시 테이블을 사용할 수 없는데 이 경우 디스크 기반의 임시 테이블을 사용한다.
  * UNION이나 UNION ALL에서 SELECT되는 칼럼 중에서 길이가 512바이트 이상인 크기의 칼럼이 있는 경우
  * GROUP BY나 DISTINCT 칼럼에서 512바이트 이상인 크기의 칼럼이 있는 경우
  * 메모리 임시 테이블의 크기가 tmp_table_size 또는 max_heap_table_size 시스템 변수보다 크거나 temptable_max_ram 시스템 변수 값보다 큰 경우

#### 9.2.6.4 임시 테이블 관련 상태 변수
* 실행 계획에서 "Using temporary"가 표시되면 임시 테이블의 사용했다는 사실을 알수 있지만 메모리 임시테이블인지 디스크 임시 테이블인지 임시 테이블이 하나만 사용됬는지 알 수 없다.
* 임시 테이블이 생성 정보를 알기 위해서 MySQL 서버의 상태 변수(`SHOW SESSION STATUS LIKE ‘Created_tmp%’;`)를 확인하면 된다.
  * `Created_tmp_tables`: 만들어진 내부 임시 테이블의 개수를 누적하는 상태 값
  * `Created_tmp_disk_tables`: 디스크에 내부 임시 테이블이 만들어진 개수만 누적해서 가지고 있는 상태 값

## 9.3 고급 최적화
* 실행 계획을 수립할 때 통계 정보와 옵티마이저 옵션을 결합해서 최적의 실행 계획을 수립하게 된다.
* 옵티마이저 옵션은 크게 2가지로 구분한다.
  * 조인 관련된 옵티마이저 옵션
  * 옵티마이저 스위치

### 9.3.1 옵티마이저 스위치 옵션
* 옵티마이저 스위치 옵션은 `optimizer_switch` 시스템 변수를 이용해서 제어하고, 여러 개의 옵션을 세트로 묶어서 설정한다.

##### 옵티마이저 스위치 최적화 옵션
<table>
    <tr>
        <th>옵티마이저 스위치 이름</th>
        <th>기본값</th>
        <th>설명</th>
    </tr>
    <tr>
        <td>batched_key_access</td>
        <td>off</td>
        <td>BKA 조인 알고리즘을 사용할지 여부 설정</td>
    </tr>
    <tr>
        <td>block_nested_loop</td>
        <td>on</td>
        <td>Block Nested Loop 조인 알고리즘을 사용할지 여부 설정</td>
    </tr>
    <tr>
        <td>engine_condition_pushdown</td>
        <td>on</td>
        <td>Engine Condition Pushdown 기능을 사용할지 여부 설정</td>
    </tr>
    <tr>
        <td>index_condition_pushdown</td>
        <td>on</td>
        <td>Index Condition Pushdown 기능을 사용할지 여부 설정</td>
    </tr>
    <tr>
        <td>use_index_extensions</td>
        <td>on</td>
        <td>Index Extension 최적화를 사용할지 여부 설정</td>
    </tr>
    <tr>
        <td>index_merge</td>
        <td>on</td>
        <td>Merge 최적화를 사용할지 여부 설정</td>
    </tr>
    <tr>
        <td>index_merge_intersection</td>
        <td>on</td>
        <td>Merge Intersection 최적화를 사용할지 여부 설정</td>
    </tr>
    <tr>
        <td>index_merge_sort_union</td>
        <td>on</td>
        <td>Merge Sort Union 최적화를 사용할지 여부 설정</td>
    </tr>
    <tr>
        <td>index_merge_union</td>
        <td>on</td>
        <td>Index Merge Union 최적화를 사용할지 여부 설정</td>
    </tr>
    <tr>
        <td>mrr</td>
        <td>on</td>
        <td>MRR 최적화를 사용할지 여부 설정</td>
    </tr>
    <tr>
        <td>mrr_cost_based</td>
        <td>on</td>
        <td>비용기반의 MRR 최적화를 사용할지 여부 설정</td>
    </tr>
    <tr>
        <td>semijoin</td>
        <td>on</td>
        <td>세미 조인 최적화를 사용할지 여부 설정</td>
    </tr>
    <tr>
        <td>firstmatch</td>
        <td>on</td>
        <td>FirstMatch 세미 조인 최적화를 사용할지 여부 설정</td>
    </tr>
    <tr>
        <td>loosescan</td>
        <td>on</td>
        <td>LooseScan 세미 조인 최적화를 사용할지 여부 설정</td>
    </tr>
    <tr>
        <td>materialization</td>
        <td>on</td>
        <td>Materialization 최적화를 사용할지 여부 설정</td>
    </tr>
    <tr>
        <td>subquery_materialization_cost_based</td>
        <td>on</td>
        <td>비용 기반의 Materialization 최적화를 사용할지 여부 설정</td>
    </tr>
</table>

#### 9.3.1.1 MRR과 배치 키 액세스(mrr & batched_key_access)
* MRR(Multi-Range Read) 또는 DS-MRR(Disk Sweep Multi-Range Read)라고도 한다.
* 기존에는 네스티드 루프 조인 방식을 사용하고, 네스티드 루프 조인 방식에서는 조인 처리를 MySQL 엔진이 담당하고, 실제 레코드를 검색하고 읽는 부분은 스토리지 엔진이 담당하는데 이 방식에선 스토리지 엔진에서 최적화를 수행할 수 없다.
  * `네스티드 루프 조인 방식`: 드라이빙 테이블의 레코드를 한 건 읽어서 드리븐 테이블의 일치하는 레코드를 찾아서 조인을 수행하는 방식
* MySQL 서버에서는 네스티드 루프 조인 방식을 사용할 때 스토리지 엔진에서 최적화를 수행할 수 없다는 단점을 보완하기 위해서 조인 버퍼에 조인 대상을 버퍼링한다. (드라이빙 테이블과 드리븐 테이블을 바로 조인하지 않고 조인 대상을 버퍼링하는 것이다)
* 조인 버퍼에 레코드가 가득 차면 MySQL 엔진은 버퍼링된 레코드를 스토리지 엔진으로 한 번에 요청해서 디스크 읽기를 최소화할 수 있는데 이런 방식을 MRR이라고 한다.
* MRR을 응용해서 실행되는 조인 방식을 BKA(Batched Key Access) 조인이라고 하는데 부가적인 정렬 작업이 필요해서 성능이 저하되기도 한다.

#### 9.3.1.2 블록 네스티드 루프 조인
* 조인의 연결 조건이 되는 칼럼에 모두 인덱스가 있는 경우 사용되는 조인 방식이다.
* 네스티드 루프 조인과 블록 네스티드 루프 조인의 차이점은 조인 버퍼 사용 여부와 조인에서 드라이빙 테이블과 드리븐 테이블이 어떤 순서로 조인되는지이다.
* 조인은 드라이빙 테이블에서 일치하는 레코드의 건수만큼 드리븐 테이블을 검색하면서 처리된다. 그래서 드리븐 테이블을 검색할 때 인덱스를 사용할 수 없는 쿼리는 느려지고 옵티마이저는 최대한 드리븐 테이블의 검색이 인덱스를 사용할 수 있게 실행 계획을 수립한다.
* 어떤 방식으로도 풀 스캔(풀 테이블 스캔, 인덱스 풀 스캔)을 피할 수 없으면 옵티마이저는 드라이빙 테이블에서 읽은 레코드를 메모리에 캐시(조인 버퍼)한 후 드리븐 테이블과 이 메모리 캐시를 조인하는 형태로 처리한다.
* 조인 버퍼가 사용되는 쿼리에서는 조인의 순서가 거꾸로인 것처럼 실행된다. A가 드라이빙, B가 드리븐 테이블일 때, A에서 검색된 레코드를 조인 버퍼에 담아두고, B의 레코드를 먼저 읽고 조인 버퍼에서 일치하는 레코드를 찾는 방식으로 처리된다.
* 블록 네스티드 루프 조인 방식은 네스티드 루프 조인 방식의 한계를 개선하기 위해서 나온 차선책이며 근본적인 해결책은 아니다.

#### 9.3.1.3 인덱스 컨디션 푸시다운(index_condition_pushdown)
* 데이터베이스의 인덱스를 효과적으로 활용하여 쿼리 성능을 개선하는 방법입니다.

employees라는 테이블에 first_name, last_name 컬럼이 존재하고, 두 컬럼에 대한 ix_lastname_firstname라는 인덱스가 존재한다고 가정합니다.

인덱스 컨디션 푸시다운을 사용하지 않는다면 `SELECT * FROM employees WHERE last_name='Action' AND first_name LIKE '%sal';`라는 쿼리가 실행됬을 때 `last_name='Action'` 조건은 인덱스 레인지 스캔을 사용할 수 있지만 `first_name LIKE '%sal'`와 같이 와일드 카로 시작되는 값에 대해서는 인덱스가 적용되지 않기 때문에 `last_name='Action'` 조건은 인덱스 레인지 스캔을 하고 해당하는 테이블 레코드를 전부 읽은 후 `first_name LIKE '%sal'` 조건에 부합하는 여부를 비교하여 레코드를 반환하기 때문에 2번의 테이블 읽기가 발생한다.

인덱스를 비교하는 작업이 InnoDB 스토리지 엔진에서 읽어나기 때문에 last_name에 해당하는 인덱스를 비교하는 작업이 실행 InnoDB 스토리지 엔진에서 일어나고, MySQL 엔진에서 first_name의 조건을 비교하는 작업이 일어난다.

인덱스 컨디션 푸시다운을 사용하면 인덱스를 범위 제한 조건으로 사용하지 못하는 조건이라도 인덱스에 포함된 칼럼의 조건이라면 같이 모아서 스토리지 엔진으로 전달하기 때문에 불필요한 2번의 테이블 읽기가 발생하지 않는다.

#### 9.3.1.4 인덱스 확장(use_index_extensions)
* 인덱스 확장 옵티마이저 옵션은 InnoDB 스토리지 엔진을 사용하는 테이블에서 세컨더리 인덱스에 자동으로 추가된 프라이머리 키를 활용할 수 있게 할지를 결정하는 옵션이다.
* InnoDB 스토리지 엔진은 프라이머리 키를 클러스터링 키로 생성하기 때문에 모든 세컨더리 인덱스는 리프 노드에 프라이머리 키 값을 가진다.

예를 들어 A테이블가 존재할 때 프라이머리 키가 (dept_no, emp_no)고 세컨더리 인덱스가 (from_date)라고 가정해본다.

세컨더리 인덱스인 (from_date)은 레코드를 찾아가기 위해 프라이머리 키 (dept_no, emp_no) 컬럼을 리프 노드에 포함한다. 즉 세컨더리 인덱스에는 (from_date, dept_no, emp_no) 조합으로 인덱스를 생성한 것과 흡사하게 작동한다.

#### 9.3.1.5 인덱스 머지
* 인덱스를 이용해 쿼리를 실행하면 대부분 옵티마이저는 테이블별로 하나의 인덱스만 사용하도록 실행 계획을 수립한다.
* 인덱스 머지 실행 계획을 사용하면 하나의 테이블에 대해 2개 이상의 인덱스를 이용해 쿼리를 처리한다.
* 조건이 여러개여도 하나의 인덱스로 검색하고 나머지는 체크하는 형태로 하는 것이 일반적이며, 쿼리에 사용된 조건이 서로 다른 인덱스를 사용할 수 있고 그 조건을 만족하는 레코드 건수가 많을 것으로 예상될 때 MySQL 서버는 인덱스 머지 실행 계획을 선택한다.
* 각각의 결과를 어떤 방식으로 병합할지에 따라 아래 세가지로 구분된다.
  * index_merge_intersection
  * index_merge_sort_union
  * index_merge_union

#### 9.3.1.6 인덱스 머지 - 교집합(index_merge_intersection)
* 2개 이상의 WHERE 조건을 가지고 있고, 모두 인덱스를 가지고 있어서 인덱스를 사용할 수 있을 때 모든 인덱스를 사용해서 쿼리를 처리하는 방식이다.
* 실행 계획의 Extra 컬럼에 "Using intersect"라고 표시되면 쿼리가 여러 개의 인덱스를 각각 검색하여 그 결과의 교집합만 반환한 것을 의미한다.
* 인덱스 머지가 아니였다면 하나의 인덱스만 사용해서 레코드를 가져온 후 조건에 일치하는 레코드를 다시 찾아서 반환하겠지만 모든 인덱스를 사용해서 교집합만 가져온다면 상대적으로 많은 레코드를 가져와야할 때 효율적으로 처리할 수 있다.
* `index_merge_intersection` 옵션을 통해서 활성화/비활성화가 가능하다.

예를 들어 `SELECT * FROM employees WHERE first_name='Georgi' AND emp_no BETWEEN 10Q0Q AND 20000;` 라는 쿼리를 실행하면 `first_name='Georgi'`에 해당하는 조건이 253개 `emp_no BETWEEN 10Q0Q AND 20000`는 10000개의 레코드가 존재하고, 두 조건을 만족하는 레코드는 14개라면 당연히 모든 인덱스를 통해서 14건만 가져오는 것이 효율적이다.

#### 9.3.1.7 인덱스 머지 - 합집합(index_merge_union)
* 인덱스 머지의 `Using union`은 where절에 사용된 2개 이상의 조건이 각각의 인덱스를 사용하되 OR 연산자로 연결된 경우에 사용되는 최적화다.
* MySQL 서버는 두 집합에서 하나씩 가져와서 사로 비교하면서 프라이머리 키를 기준으로 중복된 값을 정렬없이 걸러내고 중복 제거를 수행할 때 우선순위 큐를 사용한다.

<img src="./그림 9.12.png">

#### 9.3.1.8 인덱스 머지 - 정렬 후 합집합(index_merge_sort_union)
* 정렬돼 있지 않은 경우 인덱스 머지 작업을 하는 도중에 결과의 정렬이 필요한 경우 "Sort union" 알고리즘을 사용한다.
* MySQL 서버는 인덱스 머지 최적화에서 중복 제거를 위해 강제로 정렬을 수행해야 하는 경우에 "Using sort_union" 가 실행 계획에 표시된다.

#### 9.3.1.9 세미 조인(semijoin)
* 다른 테이블과 실제 조인을 수행하지는 않고, 단지 다른 테이블에서 조건에 일치하는 레코드가 있는지 없는지만 체크하는 형태의 쿼리를 세미 조인이라고 한다.
```
mysql〉 SELECT *
        FROM employees e
        WHERE e.emp_no IN
          (SELECT de.emp_no FROM dept_emp de WHERE de.from_date='1995-01-01');
```
* MySQL 서버 매뉴얼에는 아래와 같은 세미 조인 최적화가 있다.
  * Table Pull-out
  * Duplicate Weed-out
  * First Match
  * Loose Scan
  * Materialization

#### 9.3.1.10 테이블 풀-아웃(Table Pull-out)
* Table pullout 최적화는 세미 조인의 서브쿼리에 사용된 테이블을 아우터 쿼리로 끄집어낸 후에 쿼리를 조인 쿼리로 재작성하는 형태의 최적화다.
* Table pullout 최적화가 사용됐는지 정확하게 확인하는 방법은 EXPLAIN 명령 실행 직후, SHOW WARNINGS 명령으로 MySQL 옵티마이저가 재작성한 쿼리를 보는 것이다. IN (subquery) 형태가 사라지고, JOIN으로 쿼리가 재작성되어 있다.
* Table pullout 최적화는 모든 형태의 서브쿼리에서 사용될 수 있는 것은 아니고, 몇 가지 제한 사항과 특성이 존재한다.
  * 세미 조인 서브쿼리에서만 사용 가능하다.
  * 서브쿼리 부분이 유니크 인덱스나 프라이머리 키 룩업으로 결과가 1건인 경우에만 사용 가능하다.
  * MySQL에서는 가능하면 Table pullout 최적화를 최대한 적용한다.
  * 서브쿼리의 모든 테이블이 아우터 쿼리로 끄집어 낼 수 있다면 서브쿼리 자체는 없어진다.
  * 튜닝에서 최대한 서브쿼리를 조인으로 풀어서 사용하라는 가이드가 많은데 Table pullout이 이 가이드를 실행하는 것이라 서브쿼리를 굳이 조인으로 풀어서 사용할 필요가 없다.

#### 9.3.1.11 퍼스트 매치(firstmatch)
* First Match 최적화 전략은 IN (subquery) 형태의 세미 조인을 EXISTS (subquery) 형태로 튜닝한 것과 비슷한 방법으로 실행된다.
* First Match 최적화가 사용되면 실행 계획의 Extra 칼럼에는 FirstMatch(table-N) 문구가 표시된다.

예를 들어 테이블 A, B가 존재할 때 A 테이블의 레코드에 대해 B 테이블에서 일치하는 레코드 1건만 찾으면 더 이상 테이블 검색을 하지 않는데 이는 EXISTS(subquery)와 동일하게 처리된다.

실제로는 서브쿼리가 아니라 조인으로 풀어서 실행하면서 일치하는 첫번째 레코드만 검색하는 최적화를 실행한 것이다.

#### 9.3.1.12 루스 스캔(loosescan)
* 세미 조인 서브쿼리 최적화의 루스 스캔은 루스 인덱스 스캔과 비슷한 읽기 방식을 사용한다.
* 루스 스캔 최적화는 루스 인덱스 스캔으로 서브쿼리 테이블을 읽고, 아우터 테이블을 드리븐으로 사용해서 조인을 수행한다.
* 서브쿼리 부분이 루스 인덱스 스캔을 사용할 수 있는 조건이 갖춰져야 사용할 수 있는 최적화다.

<img src="./그림 9.14.png">

#### 9.3.1.13 구체화(Materialization)
* 구체화 최적화는 세미 조인에 사용된 서브쿼리를 통째로 구체화해서 쿼리를 최적화한다는 의미다.
* 구체화는 내부 임시 테이블을 생성한다는 것을 의미한다.
* 구체화 최적화는 다른 서브쿼리 최적화와는 달리, 서브쿼리 내에 GROUP BY 절이 있어도 사용할 수 있다.
  
* 구체화 최적화가 사용 가능한 쿼리도 제한 사항과 특성이 존재한다.
  * IN(subquery) 에서 서브쿼리는 상관 서브쿼리(Correlated subquery)가 아니어야 한다.
    * `상관 서브쿼리(Correlated subquery)`: 부모 명령과 자식인 서브쿼리가 특정 관계를 맺는 것을 의미한다.
  * 서브쿼리는 GROUP BY나 집합 함수들이 사용돼도 구체화를 사용할 수 있다.
  * 구체화가 사용된 경우에는 내부 임시 테이블이 사용된다.

#### 9.3.1.14 중복 제거(Dubplicated Weed-out)
* Dubplicated Weed-out은 `세미 조인 서브쿼리를 일반적인 INNER JOIN 쿼리로 바꿔서 실행하고 마지막에 중복된 레코드를 제거하는 방법`으로 처리되는 최적화 알고리즘이다.
* 실행 계획에 "Dubplicated Weed-out"이 표시되지는 않지만, Extra 칼럼에 "Start temporary", "End temporary" 문구가 별도로 표기된다. Start/End temporary 문구의 구간이 Dubplicated Weed-out 최적화의 처리 과정이라고 보면 된다.
* Dubplicated Weed-out 여러가지 장점과 제약 사항이 있다.
  * 서브쿼리가 상관 서브쿼리라고 하더라도 사용할 수 있는 최적화다.
  * 서브쿼리가 GROUP BY나 집합 함수가 사용된 경우에는 사용될 수 없다.
  * Duplicate Weedout은 서브쿼리의 테이블을 조인으로 처리하기 때문에 최적화할 수 있는 방법이 많다.

#### 9.3.1.15 컨디션 팬아웃(condition_fanout_filter)
* 조인을 실행할 때 테이블의 순서는 쿼리의 선능에 매우 큰 영향을 미친다.
  * A 테이블의 레코드가 1만 건, B 테이블이 10건일 때 A가 드라이빙 테이블인 경우 B 테이블을 1만 번 읽어야 한다.
* MySQL 옵티마이저는 `여러 테이블이 조인되는 경우 가능하다면 일치하는 레코드 건수가 적은 순서대로 조인을 실행`한다.
* condition_fanout_filter를 활성화하면 filtered 컬럼의 값이 조건을 충족하는 레코드의 비율을 미리 예측하는데 MySQL 옵티마이저가 조건을 만족하는 레코드 건수를 정확하게 예측할 수 있다면 더 빠른 실행 계획을 만들어 낼 수 있다.
* condition_fanout_filter 최적화가 활성화 시 특정 조건을 만족하는 레코드의 비율을 미리 예측할 수 있다.
  * WHERE 조건절에 사용된 칼럼에 대해 인덱스가 있는 경우
  * WHERE 조건절에 사용된 칼럼에 대해 히스토그램이 존재하는 경우
    * `히스토그램(Histogram)`: 데이터 분석 및 쿼리 성능 최적화를 위한 기능 중 하나로 열의 값 분포와 특정 값 범위에 속하는 행의 개수를 표시하는데, 컬럼의 데이터 분포도를 의미한다.
* condition_fanout_filter 최적화 기능을 활성화하면 옵티마이저는 더 정교한 계산을 하므로 더 많은 시간, 컴퓨팅 자원이 소모되서 쿼리가 간단한 경우에는 큰 도움이 되지 않을 수도 있다.

#### 9.3.1.16 파생 테이블 머지(derived_merge)
* 예전 버전의 MySQL 서버에서는 FROM 절에 사용된 서브쿼리는 먼저 실행해서 그 결과를 임시 테이블로 만든 다음 외부 쿼리 부분을 처리한다.
* MySQL 서버에서는 `FROM 절에 사용된 서브쿼리를 파생 테이블`이라고 부른다.
* 임시 테이블에 레코드가 많아진다면 임시 테이블로 레코드를 복사하고 읽는 오버헤드로 인해 쿼리 성능이 저하된다.
* MySQL 5.7 버전부터는 파생 테이블로 만들어지는 서브쿼리를 외부 쿼리와 병합해서 서브쿼리 부분을 제거하는 최적화가 도입됬고, `derived_merge` 최적화 옵션을 통해서 이러한 임시 테이블을 최적화를 활설화할지 결정한다.
* 아래와 같은 조건에는 옵티마이저가 자동으로 서브쿼리를 외부 쿼리로 병합할 수 없다.
  * SUM() 또는 MIN(), MAX() 같은 집계 함수와 윈도우 함수(Window Function)가 사용된 서브쿼리
    * `윈도우 함수`: Group By와 비슷하게 데이터를 그룹화하여 집계해주는 함수로 Group by 없이 SUM(), MIN(), MAX()를 썼을 떄를 의미한다.
    ```
    mysql> SELECT SUM(profit) OVER (PARTITION BY country) FROM table
    ```
  * DISTINCT가 사용된 서브쿼리
  * GROUP BY나 HAVING이 사용된 서브쿼리
  * LIMIT가 사용된 서브쿼리
  * UNION 또는 UNION ALL을 포함하는 서브쿼리
  * SELECT 절에 사용된 서브쿼리
  * 값이 변경되는 사용자 변수가 사용된 서브쿼리

#### 9.3.1.17 인비저블 인덱스(use_invisible_indexes)
* 인덱스를 삭제하지 않고, 해당 인덱스를 사용하지 못하게 제어하는 기능이다.
```
-- // 옵티마이저가 인덱스를 사용/미사용하도록 변경
mysql> ALTER TABLE [테이블 이름] ALTER INDEX [인덱스 이름] [VISIBLE/INVISIBLE];
```
* `use_invisible_indexes` 옵션을 on으로 설정하면 INVISIBLE 상태의 인덱스도 옵티마이저가 볼 수 있다.

#### 9.3.1.18 스킵 스캔(skip_scan)
* 인덱스의 핵심은 값이 정렬돼 있다는 것이며, 인덱스를 구성하는 컬럼의 순서가 매우 중요하다.

예를 들어 (A, B, C) 컬럼으로 구성된 인덱스가 있을 때 쿼리의 WHERE 절에 A와 B 컬럼에 대한 조건이 있다면 이 쿼리는 A, B 컬럼까지만 인덱스를 활용할 수 있고, B, C 칼럼에 대한 조건을 가지고 있다면 이 쿼리는 인덱스를 활용할 수 없다.

인덱스 스킵 스캔은 제한적이지만 인덱스의 순서에 대한 제약 사항을 뛰어넘을 수 있는 최적화 기법이다.

* 인덱스의 선행 칼럼이 조건절에 사용되지 않더라도 후행 칼럼의 조건만으로도 인덱스를 이용한 쿼리 성능 개선이 가능하다.
* 인덱스에서 후행 칼럼 조건만으로 인덱스를 사용할 때 사용하지 않는 선행 칼럼의 값을 가져와서 조건이 있는 것처럼 최적화하기 때문에 인덱스의 선행 칼럼이 매우 다양한 값을 가지는 경우에는 비효율적일 수 있으므로, 옵티마이저는 인덱스의 선행 칼럼이 소수의 유니크한 값을 가질 때만 인덱스 스킵 스캔 최적화를 사용한다.

#### 9.3.1.19 해시 조인
* 해시 조인이 네스티드 루프 조인보다 빠르다고 생각하지만 항상 빠른 것은 아니다.
  * 네스티드 루프 조인의 경우 테이블 크기가 커질수록 처리 시간이 증가하지만 해시 조인의 경우 일정한 처리 성능을 유지한다. 반대로 말하면 테이블의 크기가 작을 수록 네스티드 루프 조인이 빠를수도 있다는 것이다.
* 해시 조인은 첫 번째 레코드를 찾는 데는 시간이 많이 걸리고, 최종 레코드를 찾는 데까지 시간이 많이 걸리지 않기 때문에 `최고 스루풋(best throughput)` 전략에 적합하다. 
* 네스티드 루프 조인은 첫 번째 레코드를 찾는 데는 시간이 많이 걸리지 않고, 최종 레코드는 찾는 데까지 시간이 많이 걸리기 때문에 `최고 응답 속도(best response-time)` 전략에 적합하다.
* 일반적인 웹 서비스는 온라인 트랜잭션(OLTP) 서비스라서 응답 속도가 더 중요하고, 분석 서비스는 전체 스루풋이 더 중요하다.
* MySQL은 온라인 트랜잭션 처리를 위한 범용 RDBMS라서 응답 속도에 집중해야 하기 때문에 해시 조인 최적화는 네스티드 루프 조인이 사용되기에 적합하지 않은 경우를 위한 차선책이다.
* 일반적으로 해시 조인은 빌드 단계(Build-phase)와 프로브 단계(Probe-phase)로 나뉘어 처리된다.
  * `빌드 단계(Build-phase)`: 조인 대상 테이블 중에서 레코드 건수가 적어서 해시 테이블로 만들기에 용이한 테이블을 골라서 메모리에 해시 테이블을 생성하는 작업을 수행한다. 해시 테이블을 만들 때 사용되는 원본 테이블을 빌드 테이블이라고도 한다.
  * `프로브 단계(Probe-phase)`: 나머지 테이블의 레코드를 읽어서 해시 테이블의 일치 레코드를 찾는 과정이다. 이 나머지 테이블을 프로브 테이블이라고 한다.
* 해시 테이블을 메모리에 저장할 때 조인 버퍼를 사용하고, 해시 테이블이 조인 버퍼 메모리보다 큰 경우 빌드 테이블과 프로브 테이블을 청크 단위로 나눠서 저장된 청크 개수만큼 반복 처리하여 완성된 조인 결과를 만들어 낸다.
* MySQL 옵티마이저는 빌드 테이블 크기에 따라 클래식 해시 조인 알고리즘(메모리에서 모두 처리 가능한 경우), 그레이스 해시 조인 알고리즘(해시 테이블이 조인 버퍼 메모리보다 큰 경우)을 하이브리드하게 활용하도록 구현돼 있다.

<img src="./그림 9.17.png">

<img src="./그림 9.18.png">

<img src="./그림 9.19.png">

#### 9.3.1.20 인덱스 정렬 선호(prefer_ordering_index)
* MySQL 옵티마이저는 ORDER BY 또는 GROUP BY를 인덱스를 사용해 처리 가능한 경우 쿼리의 실행 계획에서 이 인덱스의 가중치를 높이 설정해서 실행된다.
* 체크해야 하는 레코드 건수가 상당히 많음에도 불구하고 정렬된 인덱스를 활용으로 실행 계획이 수립되면 빈번하진 않지만 옵티마이저가 가끔 실수를 한다.
* 옵티마이저가 ORDER BY를 위한 인덱스에 너무 가중치를 부여하지 않도록 `prefer_ordering_index` 옵션을 사용할 수 있다. 기본값은 on이지만, 옵티마이저가 자주 실수한다면 off로 설정할 수 있다.

### 9.3.2 조인 최적화 알고리즘
* 조인 쿼리의 실행 계획 최적화를 위한 알고리즘 2개가 존재한다.
  * Exhaustive 검색 알고리즘
  * Greedy 검색 알고리즘
* 조인 최적화에서 하나의 쿼리에서 테이블의 개수가 많아지면 실행 계획을 수립하는 데 굉장히 오랜 시간이 걸리게 된다.

#### 9.3.2.1 Exhaustive 검색 알고리즘
* FROM 절에 명시된 모든 테이블의 조합에 대해 실행 계획의 비용을 계산해서 최적의 조합 1개를 찾는 방법이다.
* 테이블이 N개라면 가능한 조합은 N!(Factorial)개가 되서 테이블 개수가 증가할수록 시간이 기하급수적으로 증가한다.

#### 9.3.2.2 Greedy 검색 알고리즘
* Exhaustive 검색 알고리즘의 시간 소모적인 문제점을 해결하기 위해 도입된 조인 최적화 기법이다.

<img src="./그림 9.21.png">

* Greedy 검색 알고리즘의 절차는 아래와 같다.
  1. 전체 N개의테이블 중에서 optimizer_search_depth 시스템 설정 변수에 정의된 개수의 테이블로 가능한 조인 조합을 생성
  2. 1번에서 생성된 조인 조합 중에서 최소 비용의 실행 계획 하나를 선정
  3. 2번에서 선정된 실행 계획의 첫 테이블을 부분 실행 계획의 첫 번째 테이블로 선정
  4. 전체 N-1개의 테이블 중에서 optimizer_search_depth 시스템 설정 변수에 정의된 개수의 테이블로 가능한 조인 조합을 생성
  5. 4번에서 생성된 조인 조합들을 하나씩 3번에서 생성된 부분 실행 계획에 대입해 실행 비용을 계산
  6. 5번의 비용 계산 결과 최적의 실행 계획에서 두 번째 테이블을 3번에서 새성된 부분 실행 계획의 두 번째 테이블로 선정
  7. 남은 테이블이 모두 없어질 때까지 4~6번까지의 과정을 반복
  8. 최종적으로 부분 실행 계획이 테이블의 조인 순서로 결정됨
* 조인 최적화를 위한 시스템 변수가 제공된다.
  * `optimizer_search_depth`
    * Greedy 검색 알고리즘과 Exhaustive 검색 알고리즘 중에서 어떤 알고리즘을 사용할지 결정하는 시스템 변수다.
    * 0~62 사이의 정수로 설정할 수 있고, 1~62는 지정된 개수로 한정해서 최적의 실행 계획을 산출하고, 0은 옵티마이저가 자동으로 결정한다.
    * 설정 값과 쿼리의 조인 테이블 개수에 따라 Exhaustive 검색만 사용되거나 Greedy 검색과 Exhaustive 검색이 동시에 사용된다.
  * `optimizer_prune_level`
    * Heuristic 검색이 작동s하는 방식을 제어한다.

## 9.4 쿼리 힌트
옵티마이저에게 쿼리의 실행 계획을 어떻게 수립해야 할지 알려줄 수 있는 다양한 방법이 필요한데 이런 목적으로 쿼리 힌트가 제공된다.

사용 가능한 쿼리 힌트는 2가지로 구분할 수 있다.
* 인덱스 힌트
* 옵티마이저 힌트

### 9.4.1 인덱스 힌트
* 인덱스 힌트는 모두 MySQL 서버에 옵티마이저 힌트가 도입되기 전에 사용되던 기능들이며 가능하면 옵티마이저 힌트를 사용하는 것이 낫다.
* 인덱스 힌트는 SELECT, UPDATE 명령에서만 사용할 수 있다.

#### 9.4.1.1 STRAIGHT_JOIN
* STRAIGHT_JOIN은 SELECT, UPDATE, DELETE 쿼리에서 여러 개의 테이블이 조인되는 경우 조인 순서를 고정하는 역할을 한다.
* 여러 개의 테이블이 조인할 때 어느 테이블이 드라이빙 테이블 되고 어느 테이블이 드리븐 테이블이 될지 알 수 없어서 조인 순서 고정이 필요한 경우 STRAIGHT_JOIN을 사용한다.
```
-- 두 문법은 표기법만 다를 뿐 동일하다.
mysql> SELECT STRAIGHT_JOIN
        ...
mysql> SELECT /*! STRAIGHT_JOIN */
        ...
```
* STRAIGHT_JOIN 힌트는 옵티마이저가 FROM 절에 명시된 테이블의 순서대로 조인을 수행하도록 유도한다.
* 다음 기준에 맞게 조인 순서가 결정되지 않는 경우에만 STRAIGHT_JOIN 힌트로 조인 순서를 조정하는 것이 좋다.
  * `임시 테이블과 일반 테이블의 조인`: 일반적으로 임시 테이블을 드라이빙 테이블로 선정하는 것이 좋다.
  * `임시 테이블끼리 조인`: 임시 테이블은 인덱스가 없기 때문에 어떤 테이블을 먼저 읽어도 상관없어서 크기가 작은 테이블을 드라이빙으로 하는 것이 좋다.
  * `일반 테이블끼리 조인`: 양쪽 모두 조인 컬럼에 인덱스가 있거나 양쪽 모두 인덱스가 없으면 레코드 건수가 적은 테이블을 드라이빙으로 해주는 것이 좋으며, 그 외에는 조인 컬럼에 인덱스가 없는 테이블을 드라이빙으로 선택하는 것이 좋다.

여기서 언급하는 레코드 건수는 테이블 전체 레코드 건수가 아닌 인덱스를 사용할 수 있는 WHERE 조건까지 포함해서 그 조건을 만족하는 레코드 건수를 의미한다.

* STRAIGHTJOIN 힌트와 비슷한 역할을 하는 옵티마이저 힌트는 아래와 같다.
  * JOIN_FIXED_ORDER
  * JOIN_ORDER 
  * JOIN_PREFIX 
  * JOIN_SUFFIX


#### 9.4.1.2 USE INDEX / FORCE INDEX / IGNORE INDEX
* 인덱스 힌트를 사용하려는 인덱스를 가지는 테이블 뒤에 힌트를 명시해야 한다.
* 옵티마이저는 어떤 인덱스를 사용해야 할지 잘 선택하는 편이지만 3~4개 이상의 컬럼을 포함하는 비슷한 인덱스가 여러 개 존재하면 가끔 실수를 해서 강제로 특정 인덱스를 사용하도록 힌트를 추가해야 한다.

<table>
    <tr>
        <th>종류</th>
        <th>설명</th>
    </tr>
    <tr>
        <td>USE INDEX</td>
        <td>
            가장 자주 사용되는 인덱스이며, 옵티마이저에게 특정 테이블의 인덱스를 사용하도록 권장하는 힌트
        </td>
    </tr>
    <tr>
        <td>FORCE INDEX</td>
        <td>
            USE INDEX와 동일하지만 USE INDEX보다 옵티마이저에게 미치는 영향이 더 강한 힌트지만 USE INDEX도 영향력이 충분해서 거의 사용할 필요가 없다.
        </td>
    </tr>
    <tr>
        <td>IGNORE INDEX</td>
        <td>
            특정 인덱스를 사용하지 못하게 하는 용도로 사용되는 힌트
        </td>
    </tr>
</table>

* USE INDEX / FORCE INDEX / IGNORE INDEX 모두 용도를 명시 해줄 수 있고 아래와 같다. 하지만 옵티마이저가 최적으로 선택하기에 용도까지는 크게 고려하지 않아도 된다.
  * USE INDEX `FOR JOIN`
  * USE INDEX `FOR ORDER BY`
  * USE INDEX `FOR GROUP BY`

#### 9.4.1.3 SQL_CALC_FOUND_ROWS
* LIMIT는 조건을 만족하는 레코드가 LIMIT에 명시된 수 보다 많아도 명시된 수만큼 만족하는 레코드를 찾으면 즉시 검색 작업을 멈춘다.
* SQL_CALC_FOUND_ROWS 힌트가 포함된 쿼리는 `끝까지 검색을 수행`한다.
* SQL_CALC_FOUND_ROWS 힌트는 성능 향상을 위해 만들어진 힌트가 아닌 개발자의 편의를 위해 만들어진 힌트라서 사용하지 않는 방향을 추천한다.

### 9.4.2 옵티마이저 힌트
* MySQL 8.0 버전에서 사용 가능한 옵티마이저 힌트는 종류와 미치는 영향 범위가 매우 다양하다.

#### 9.4.2.1 옵티마이저 힌트 종류
* 옵티마이저 힌트는 영향 범위에 따라 4개의 그룹으로 나눌 수 있다. 하지만 이 구분으로 인해 힌트 사용 위치가 달라지는 것은 아니다.
  * 인덱스
  * 테이블
  * 쿼 리블록
  * 글로벌(쿼리 전체)

#### 9.4.2.2 MAX_EXECUTION_TIME
* 옵티마이저 힌트 중에서 유일하게 `쿼리의 실행 계획에 영향을 미치지 않고`, 단순히 `쿼리의 최대 실행 시간을 설정하는 힌트`다.
* MAX_EXECUTION_TIME 힌트를 통해서 지정한 시간이 밀리초 단위의 시간이 초과하면 쿼리는 실패한다.

#### 9.4.2.3 SET_VAR
* SET_VAR는 `실행 계획을 바꾸는 용도뿐 아니라 조인 버퍼나 정렬용 버퍼(소트 버퍼)의 크기를 일시적으로 증가시켜 대용량 처리 쿼리의 성능을 향상시키는 용도`로 사용할 수 있다.
* 모든 시스템 변수를 SET_VAR 힌트로 조정할 수 없다.

#### 9.4.2.4 SEMIJOIN & NO_SEMIJOIN
* SEMIJOIN 힌트는 `어떤 세부 전략을 사용할지를 제어하는 데 사용`할 수 있다.

<table>
    <tr>
        <th>최전화 전략</th>
        <th>힌트</th>
    </tr>
    <tr>
        <td>Duplicate Weed-out</td>
        <td>
            SEMIJOIN(DUPSWEEDOUT)
        </td>
    </tr>
    <tr>
        <td>First Match</td>
        <td>
            SEMIJOIN(FIRSTMATCH)
        </td>
    </tr>
    <tr>
        <td>Loose Scan</td>
        <td>
            SEMIJOIN(LOOSESCAN)
        </td>
    </tr>
    <tr>
        <td>Materialization</td>
        <td>
            SEMIJOIN(MATERIALIZATION)
        </td>
    </tr>
    <tr>
        <td>Table Pull-out</td>
        <td>
            없음
        </td>
    </tr>
</table>

* NO_SEMIJOIN 힌트는 `특정 세미 조인 최적화 전략을 사용하지 않게` 하는데 최적화 전략들은 `상황에 따라 다른 최적화 전략으로 우외하는 것이 더 나은 성능`을 낼 수도 있기 떄문이다.

#### 9.4.2.5 SUBQUERY
* 서브쿼리 최적화는 세미 조인 최적화가 사용되지 못할 때 사하는 최적화 방법이다.

<table>
    <tr>
        <th>최전화 전략</th>
        <th>힌트</th>
    </tr>
    <tr>
        <td>IN-to-EXISTS</td>
        <td>
            SUBQUERY(INTOEXISTS)
        </td>
    </tr>
    <tr>
        <td>Materialization</td>
        <td>
            SUBQUERY(MATERIALIZATION)
        </td>
    </tr>
</table>

* 세미 조인 최적화는 IN 형태에는 사용될 수 있지만 안티 세미 조인의 최적화에는 서브쿼리 최적화가 사용된다.
* 서브쿼리 최적화 전략을 사용할 기회가 그다지 많지 않다.

#### 9.4.2.6 BNL & NO_BNL & HASHJOIN & NO_HASHJOIN
* MySQL 8.0.20 버전부터는 블록 네스티드 루프 조인까지 해시 조인 알고리즘이 대체했고, 더 이상 블록 네스티드 루프 조인이 사용되지 않는다.
* BNL과 NO_BNL 힌트는 MySQL 8.0.20 버전 이후에도 사용 가능하지만 HASHJOIN과 NO_HASHJOIN 힌트는 MySQL 8.0.18 버전에서만 유효하다.

#### 9.4.2.7 JOIN_FIXED_ORDER & JOIN_ORDER & JOIN_PREFIX & JOIN_SUFFIX
* 조인의 순서를 결정하기 위한 STRAIGHT_JOIN를 사용했는데 FROM 절에 사용된 테이블의 순서를 조인 순서에 맞게 변경해야 한다는 단점과 일부만 조인 순서를 강제하는 것이 불가능했던 단점을 보완하기 위해서 나온 힌트는 아래와 같다.
  * `JOIN_FIXED_ORDER`: STRAIGHT_JOIN과 동일하게 FROM 절의 테이블 순서대로 조인을 실행하는 힌트
  * `JOIN_ORDER`: FROM 절에 사용된 테이블의 순서가 아니라 힌트에 명시된 테이블의 순서대로 조인을 실행하는 힌트
  * `JOIN_PREFIX`: 조인에서 드라이빙 테이블만 강제하는 힌트
  * `JOIN_SUFFIX`: 조인에서 드리븐 테이블만 강제하는 힌트

#### 9.4.2.8 MERGE & NO_MERGE
* 예전 버전의 MySQL 서버는 FROM 절에 사용된 서브쿼리를 항상 내부 임시 테이블(파생 테이블)로 생성했다.
* 내부 임시 테이블은 불필요한 자원 소모를 유발해서 MySQL 5.7과 8.0 버전에서는 가능하면 `임시 테이블을 사용하지 않게 FROM 절의 서브쿼리를 외부 쿼리와 병합`하는 최적화를 도입했다.
* 때로는 내부 임시 테이블을 생성한느 것이 나은 선택이 될 수도 있고, `옵티아미저가 최적의 방법을 선택하지 못할 때, MERGE 또는 NO_MERGE 힌트를 사용`한다.

#### 9.4.2.9 INDEX_MERGE & NO_INDEX_MERGE
* MySQL 서버는 가능하다면 테이블당 하나의 인덱스만을 이용해 쿼리를 처리하려 하지만 하나의 인덱스만으로 검색 대상을 충분히 좁힐 수 없다면 다른 인덱스를 이용한다.
* 하나의 테이블에 대해 여러 개의 인덱스를 동시에 사용하는 것을 인덱스 머지라고 하는데 인덱스 머지는 성능 향상에 도움이 되지만 항상 그렇지는 않다.
* 인덱스 머지 실행 계획의 사용 여부를 제어할 때 INDEX_MERGE 와  NO_INDEX_MERGE 힌트를 사용한다.

#### 9.4.2.10 NO_ICP
* 인덱스 컨디션 푸시다운(ICP, Index Condition Pushdown) 최적화는 `사용 가능하다면 항상 성능 향상에 도움`이 되므로 최대한 사용하는 방향으로 실행 계획을 수립한다.
* 인덱스 푸시 다운으로 인해 여러 실행 계획의 비용이 잘못된다면 결과적으로 잘못된 실행 계획을 수립하게 될 수도 있다.
* 인덱스 컨디션 푸시다운으로 측정된 비용이 더 낮게 측정되서 해당 인덱스를 사용하겠지만 간혹 실제 서비스에선 오히려 비용이 더 높게 측정된 인덱스가 더 효율적일 수도 있다.
* 테이블의 데이터 분포는 항상 균등한 것이 아니기 때문에 쿼리 검색 범위에 따라 달라지며 이 같은 경우엔 인덱스 컨디션 푸시다운을 비활성화 해서 유연하고 정확하게 실행 계획을 선택할 수 있다.

#### 9.4.2.12 INDEX & NO_INDEX
* INDEX 와 NO_INDEX 옵티마이저 힌트는 에전 MySQL 서버에서 사용되던 인덱스 힌트를 대체하는 용도로 제공된다.

<table>
    <tr>
        <th>인덱스 힌트</th>
        <th>옵티마이저 힌트</th>
    </tr>
    <tr>
        <td>USE INDEX</td>
        <td>INDEX</td>
    </tr>
    <tr>
        <td>USE INDEX FOR GROUP BY</td>
        <td>GROUP_INDEX</td>
    </tr>
    <tr>
        <td>USE INDEX FOR ORDER BY</td>
        <td>ORDER_INDEX</td>
    </tr>
    <tr>
        <td>IGNORE INDEX</td>
        <td>NO_INDEX</td>
    </tr>
    <tr>
        <td>IGNORE INDEX FOR GROUP BY</td>
        <td>NO_GROUP_INDEX</td>
    </tr>
    <tr>
        <td>IGNORE INDEX FOR ORDER BY</td>
        <td>NO_ORDER_INDEX</td>
    </tr>
</table>

* 인덱스 힌트는 특정 테이블 뒤에 사용했기 때문에 별도로 힌트 내에 테이블 명 없이 인덱스 이름만 나열했지만 옵티마이저 힌트는 테이블명과 인덱스 이름을 함께 명시해야 한다.
```
-- // 옵티마이저 힌트 사용
mysql> EXPLAIN
      SELECT /*+ INDEX(employees ix_firstname) */ * 
      FROM employees
      WHERE first_name='Matt';
```