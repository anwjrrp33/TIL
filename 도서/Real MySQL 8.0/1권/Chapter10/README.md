# 10. 실행 계획
DBMS의 목적은 많은 데이터를 안전하게 저장 및 관리하고 원하는 데이터를 빠르게 조회하는 것인데 이를 위해서 옵티마이저가 쿼리를 최적으로 처리될 수 있게 실행 계획을 수립해야 한다.

실행 계획을 이해하려면 서버가 데이터를 처리하는 로직을 이해해야 한다. 이를 위해서 통계 정보와 실행 계획을 읽는 순서, 키워드, 알고리즘을 살펴본다.

## 10.1 통계 정보
5.7 버전까지는 테이블과 인덱스에 대한 개괄적인 정보를 가지고 실행 계획을 수립해서 정확도가 떨어졌다. 8.0 버전부터는 인덱스되지 않는 컬럼들에 대해서도 데이터 분포도를 수집해 저장하는 히스토그램 정보가 도입됐다.

### 10.1.1 테이블 및 인덱스 통계 정보
* 비용 기반 최적화에서 가장 중요한 것은 통계 정보인데 통계 정보가 정확하지 않다면 엉뚱한 방향으로 쿼리를 실행하기 때문이다.
* MySQL 통계 정보는 다른 DBMS에 비해 정확하지 않고 휘발성이 강해서 실제 테이블의 데이터를 일부 분석해서 통계 정보를 보완해서 사용했다.
* 5.6 버전부터는 통계 정보의 정확성을 높일 수 있는 방법이 제공되기 시작했다.

#### 10.1.1.1 MySQL 서버의 통계 정보
* 5.6 버전부터는 InnoDB 스토리지 엔진을 사용하는 테이블에 대한 통계 정보를 영구적으로 관리할 수 있게 개선됐다.
* 5.5 버전까지는 각 테이블의 통계 정보가 메모리에만 관리되서 서버가 재시작되면 통계 정보가 모두 사라졌다. 5.6 버전부터는 각 테이블의 통계 정보를 mysql 데이터베이스의 `innodb_index_stats 테이블`과 `innodb_table_stats 테이블`로 관리할 수 있게 개선됐다.
* STATS_PERSISTENT 옵션으로 영구적으로 테이블에 통계정보를 저장할지 말지를 결정할 수 있다.
  * 기본 값은 영구적(STATS_PERSISTENT=1)
  * 단기적(STATS_PERSISTENT=0)
* STATS_AUTO_RECALC 옵션으로 통계 정보를 자동으로 수집할지 여부를 결정할 수 있다.

### 10.1.2 히스토그램
* 5.7 버전까지는 단순히 인덱스된 칼럼의 유니크한 값의 개수 정도만 통계 정보로 가지고 있어서 실행 계획을 수립하기엔 부족했고, 이를 메우기 위해서 일부 페이지를 랜덤으로 가져와 참조하는 방식을 사용했다.
* 8.0 버전부터는 컬럼의 데이터 분포도를 참조할 수 있는 히스토그램 정보를 활용할 수 있다.

#### 10.1.2.1 히스토그램 정보 수집 및 삭제
* 히스토그램 정보는 컬럼 단위로 관리되는데, 자동으로 수집도지 않고 `ANALYZE TABLE … UPDATE HISTOGRAM 명령을 실행`해 수동으로 수집 및 관리된다.
* 수집된 히스토그램 정보는 시스템 딕셔너리에 함께 저장되고, MySQL 서버가 시작될 때 딕셔너리의 히스토그램 정보를 information_schema 데이터베이스의 column_statistics 테이블로 로드하기 때문에 히스토그램 정보를 조회하려면 column_statistics 테이블을 SELECT해서 참조할 수 있다.
* MySQL 8.0 버전에서는 2종류의 히스토그램 타입이 지원된다.
  * `Singleton(싱글톤 히스토그램)`: 컬럼값 개별로 레코드 건수를 관리하는 히스토그램으로 value-based 히스토그램, 도수 분포라고도 불린다.
  * `Equi-Height(높이 균형 히스토그램)`: 컬럼값의 범위를 균등한 개수로 구분해서 관리하는 히스토그램으로 Height-Balanced 히스토그램라고도 불린다.
* 히스토그램은 버킷(Bucket) 단위로 구분되어 레코드 건수나 컬럼값의 범위가 관리된다. 
  * 싱글톤 히스토그램은 컬럼이 가지는 값별로 버킷이 할당되며 높이 균형 히스토그램에서는 개수가 균등한 컬럼값의 범위별로 하나의 버킷이 할당된다.
  * 싱글톤 히스토그램은 각 버킷이 칼럼의 값과 발생 빈도의 비율의 2개 값을 가지는데 높이 균형 히스토그램은 각 버킷이 범위 시작 값과 마지막 값, 발생 빈도율과 각 버킷에 포함된 유니크한 값의 개수 등 4개의 값을 가진다.
* 싱글톤 히스토그램은 주로 코드 값과 같이 유니크한 값의 개수가 상대적으로 적은 경우 사용된다.

#### 10.1.2.2 히스토그램의 용도
* MySQL 서버에서 히스토그램이 도입되기 전에 전체 레코드 건수와 인덱스된 칼럼이 가지는 유니크한 값의 개수정도를 통계 정보로 가지고 있었다.
* 실제 응용 프로그램의 데이터는 항상 균등한 분포도를 가지지 않고, 기존 통계 정보는 이런 부분을 고려하지 못했고 이런 단점을 보완하기 위해 히스토그램이 도입됐다.
* 각 범위(버킷)별로 레코드의 건수와 유니크한 값의 개수 정보를 가지기 때문에 정확한 예측을 할 수 있다.
* 히스토그램 정보가 없으면 옵티마이저는 데이터가 균등 분포라고 예측하지만, 히스토그램이 있으면 특정 범위의 데이터가 많고 적음을 식별할 수 있다.
* 각 칼럼에 대해 히스토그램 정보가 있으면 어느 테이블을 먼저 읽어야 조인의 횟수를 줄일 수 있을지 옵티마이저가 더 정확히 판단할 수 있다.

#### 10.1.2.3 히스토그램과 인덱스
* 쿼리의 실행 계획을 수립할 때 사용 가능한 인덱스들로부터 조건절에 일치하는 레코드 건수를 대략 파악하고 최정적으로 가장 나은 실행 계획을 선택한다.
  * 조건절에 일치하는 레코드 건수를 예측하기 위해 옵티마이저는 실제 인덱스의 B-Tree를 샘플링해서 살펴보는데 이 작업 매뉴얼을 `인덱스(Index Dive)`라고 표현한다.
  * 인덱스된 칼럼을 검색 조건으로 사용하는 경우 그 칼럼의 히스토그램은 사용하지 않고 실제 인덱스 다이브를 통해 직접 수집한 정보를 활용한다. 실제 검색 조건의 대상 값에 대한 샘플링을 실행하는 것이므로 항상 히스토그램보다 정확한 결과를 기대할 수 있기 때문이다.
  * 히스토그램은 주로 인덱스되지 않은 칼럼에 대한 데이터 분포도를 참조하는 용도로 사용된다.

### 10.1.3 코스트 모델(Cost Model)
* MySQL 서버가 쿼리를 처리할려면 다양한 작업이 필요하고 예측하고 비용을 계산해서 최적의 실행 계획을 찾는데 이렇게 `전체 쿼리의 비용을 계산하는 데 필요한 단위 작업들의 비용을 코스트 모델(Cost Model)이라고 한다.`
* 코스트 모델은 mysql DB에 있는 2개 테이블에 저장돼 있는 설정값을 사용한다.
  * `server_cost`: 인덱스를 찾고 레코드를 비교하고 임시 테이블 처리에 대한 비용 관리
  * `engine_cost`: 레코드를 가진 데이터 페이지를 가져오는 데 필요한 비용 관리
* row_evaluate_cost는 스토리지 엔진이 반환한 레코드가 쿼리 조건에 일치하는지를 평가하는 단위 작업 값이 증가할수록 풀 테이블 스캔과 같이 많은 레코드를 처리하는 쿼리의 비용이 높아지고, 반대로 레인지 스캔과 같이 적은 수의 레코드를 처리하는 쿼리의 비용이 낮아진다.
* key_compare_cost는 키 값의 비교 작업에 필요한 비용 값이 증가할수록 레코드 정렬과 같이 키 값 비교 처리가 많은 경우 쿼리 비용이 높아진다.
* 코스트 모델에서 중요한 것은 각 단위 작업에 설정되는 비용 값이 커지면 어떤 실행 계획들이 고비용으로 바뀌고 어떤 실행 계획들이 저비용으로 바뀌는지를 파악하는 것이다.

## 10.2 실행 계획 확인
실행 계획은 DESC 또는 EXPLAIN 명령으로 확인할 수 있다. 8.0 버전부터는 EXPLAIN 명령에 출력 포맷과 실제 쿼리 실행 결과까지 확인할 수 있는 기능이 추가됬다.

### 10.2.1 실행 계획 출력 포맷
* 8.0 버전에서는 PARTITIONS나 EXTENDED 옵션은 문법에서 제거됐다.
* 8.0 버전부터는 FORMAT 옵션을 사용해 실행 계획의 표시 방법을 JSON, TREE, 단순 테이블 형태로 선택할 수 있다.
```
-- 테이블 포맷 표시
mysql> EXPLAIN
        ...

-- 트리 포맷 표시
mysql> EXPLAIN FORMAT=TREE
        ...

-- JSON 포맷 표시
mysql> EXPLAIN FORMAT=JSON
        ...
```

### 10.2.2 쿼리의 실행 시간 확인
* 8.0.18 버전부터는 EXPLAIN ANALYZE를 쓰면 쿼리의 실행 계획과 단계별 소요된 시간 정보를 확인할 수 있다. 이 명령은 항상 결과를 TREE 포맷으로 보여준다.
* TREE 포맷 실행 계획에서 들여쓰기는 호출 순서를 의미하며, 다음 기준으로 읽으면 된다.
  * 들여쓰기가 같은 레벨에서는 상단에 위치한 라인이 먼저 실행
  * 들여쓰기가 다른 레벨에서는 가장 안쪽에 위치한 라인이 먼저 실행
* EXPLAIN ANALYZE에 나열된 필드들의 의미
  * `actual time`: 숫자 값이 2개 표시되는데, 첫 번째 숫자 값은 첫 번째 레코드를 가져오는 데 걸린 평균 시간이고, 두 번째 숫자 값은 마지막 레코드를 가져오는 데 걸린 평균 시간이다.
  * `rows`: 해당 테이블에서 읽은 조건에 일치하는 평균 레코드 건수를 의미한다.
  * `loops`: 해당 테이블에서 읽은 정보를 이용해 해당 레코드를 찾는 작업이 반복된 횟수를 의미한다.
* 쿼리의 실행 계획이 아주 나쁜 경우라면 EXPLAIN 명령으로 먼저 실행 계획만 확인해서 어느 정도 튜닝한 후 EXPLAIN ANALYZE 명령을 실행하는 것이 좋다.

## 10.3 실행 계획 분석
MySQL 8.0 버전부터는 EXPLAIN 명령의 실행 계획의 포맷을 테이블, JSON, TREE 형태로 선택할 수 있지만 출력 포맷보다는 `실행 계획이 어떤 접근 방법을 통해서 최적화를 수행하는지, 어떤 인덱스를 사용하는지 등의 이해가 중요`하다.

실행 순서는 위에서 아래로 순서도래 표시되고(UNION, 상관 서브쿼리는 다를 수 있다) 위쪽에 출력된 결과일수록(id 컬럼이 작을수록) 쿼리의 바깥 부분이거나 먼저 접근한 테이블이고, 아래쪽에 출력된 결과일수록 쿼리의 안쪽 부분 또는 나중에 접근한 테이블에 해당한다.

### 10.3.1 id 칼럼
* 실행계획의 id 칼럼은 `단위 SELECT 쿼리 별로 부여되는 식별자 값`이며, 하나의 SELECT 문장 안에서 여러 개의 테이블을 조인하면 조인되는 테이블의 개수만큼 레코드가 출력되지만 같은 id가 부여된다.
```
mysql > EXPLAIN
        SELECT
          (SELECT COUNT(*) FROM act_expence_application) AS CNT
        FROM (
          SELECT * FROM
            act_expence_application
        ) tb1 LEFT OUTER JOIN
        act_expence_application_list tb2
        ON
          tb1.ExpenceApplicationID = tb2.ExpenceApplicationID;
----------------------------------------------------------------
1	PRIMARY	act_expence_application
1	PRIMARY	tb2
2	SUBQUERY	act_expence_application
```
* 주의할 점은 id 칼럼이 테이블의 접근 순서를 의미하지지는 않으며 `EXPLAIN format=tree 명령`을 통해서 TREE 구조로 확인하는 것이 순서를 정확히 확인할 수 있다.

### 10.3.2 select_type 칼럼
* 각 단위 SELECT 쿼리가 어떤 타입의 쿼리인지 표시되는 칼럼이다.

#### 10.3.2.1 SIMPLE
* UNION이나 서브쿼리를 사용하지 않는 단순한 SELECT 쿼리인 경우 해당 쿼리 문장의 select_type은 SIMPLE로 표시된다. (조인도 포함)
* 아무리 복잡한 쿼리라도 SIMPLE인 단위 쿼리는 하나만 존재한다. 일반적으로 제일 바깥 SELECT 쿼리가 SIMPLE이다.

#### 10.3.2.2 PRIMARY
* UNION이나 서브쿼리를 가지는 SELECT 쿼리의 가장 바깥쪽에 있는 단위 쿼리로 PRIMARY로 표시된다.
* 쿼리에서 PRIMARY인 단위 쿼리는 하나만 존재한다.

#### 10.3.2.3 UNION
* UNION으로 결합하는 단위 SELECT 쿼리 가운데 첫 번째를 제외한 두 번째 이후 단위 SELECT 쿼리로 UNION으로 표시된다.
* UNION의 첫 번째 단위 SELECT는 select_type이 임시 테이블(DERIVED)이다.

#### 10.3.2.4 DEPENDENT UNION
* UNION select_type과 같이 UNION이나 UNION ALL로 집합을 결합하는 쿼리에서 표시된다.
* DEPENDENT는 UNION이나 UNION ALL로 결합된 단위 쿼리가 외부 쿼리에 의해 영향을 받는 것을 의미한다.
```
mysql> EXPLAIN 
      SELECT *
      FROM employees e1 WHERE e1.emp_no IN (
        SELECT e2.emp_no FROM employees e2 WHERE e2.first_name='Matt' 
        UNION
        SELECT e3.emp_no FROM employees e3 WHERE e3.last_name='Matt'
      );
```

#### 10.3.2.5 UNION RESULT
* UNION(또는 UNION DISTINCT) 결과를 담아두는 테이블을 의미한다.
* 8.0 버전부터는 UNION ALL은 임시 테이블을 사용하지 않도록 기능을 개선했지만 UNION(또는 UNION DISTINCT)은 임시 테이블에 결과를 버퍼링한다.
* UNION RESULT는 실제 쿼리에서 단위 쿼리가 아니기 때문에 별도의 id 값은 부여되지 않는다.
* UNION ALL을 사용하면 임시 테이블을 버퍼링하지 않기 때문에 실행 계획에 라인이 표시되지 않는다.

#### 10.3.2.6 SUBQUERY
* 서브쿼리라고 하면 여러 가지를 통틀어서 이야기 하는데, select_type의 SUBQUERY는 `FROM 절 이외에서 사용되는 서브쿼리만을 의미`한다.
* FROM절에 사용된 서브쿼리는 DERIVED로 표시되고, 그 밖의 위치에서 사용된 서브쿼리는 전부 SUBQUERY로 표시된다.
* 서브쿼리는 사용하는 위치에 따라 다른 이름을 지닌다.
  * 중첩된 쿼리(Nested Query): SELECT되는 칼럼에 사용된 서브쿼리
  * 서브쿼리(Subquery): WHERE 절에 사용된 서브쿼리
  * 파생 테이블(Derived Table): FROM 절에 사용된 서브쿼리, 인라인 뷰 또는 서브 셀렉트라고도 부른다.
* 서브쿼리는 반환하는 값의 특성에 따라 구분된다.
  * 스칼라 서브쿼리(Scalar Subquery): 하나의 값만(칼럼이 단 하나인 레코드 1건) 반환하는 쿼리
  * 로우 서브쿼리(Row Subquery): 칼럼의 개수와 관계없이 하나의 레코드만 반환하는 쿼리

#### 10.3.2.7 DEPENDENT SUBQUERY
* 서브쿼리가 바깥쪽(Outer) SELECT 쿼리에서 정의된 컬럼을 사용하는 경우를 의미한다.
* 외부 쿼리가 먼저 수행된 후 내부 쿼리가 샐행돼야 하므로 일반 서브쿼리보다 느리다.

#### 10.3.2.8 DERIVED
* FROM 절에 사용된 서브쿼리를 의미한다.
* 5.6 버전부터는 FROM 절의 서브쿼리를 외부 쿼리와 통합하는 형태의 최적화가 수행되기도 하고, 8.0 버전부터는 최적화가 많이 개선되어 불필요한 서브쿼리는 조인으로 재작성된다.
* 쿼리를 튜닝하기 위해 실행 계획을 확인할 때 가장먼저 select_type 칼럼의 값이 DERIVED인 것이 있는지 확인해야 한다.

#### 10.3.2.9 DEPENDENT DERIVED
* `래터럴 조인으로 FROM 절의 서브쿼리에서 외부 칼럼을 참조하는 경우을 의미`한다.
* 8.0 이전 버전에서는 FROM 절의 서브쿼리는 외부 칼럼을 사용할 수 있었는데 8.0 버전부터는 래터럴 조인 기능이 추가되서 FROM 절의 서브쿼리에서도 외부 칼럼을 참조할 수 있다.

#### 10.3.2.10 UNCACHEABLE SUBQUERY
* 조건이 똑같은 서브쿼리는 내부 캐시 공간에 담아두고 캐시된 결과를 재사용할 수 있다.
* select_type이 SUBQUERY와 UNCACHEABLE SUBQUERY는 서브쿼리의 값을 캐시로 사용할 수 있는지 없는지의 차이다.
* 서브쿼리에 포함된 요소의 캐시 자체가 불가능한 경우가 있는데 그럴 경우 "UNCACHEABLE SUBQUERY"로 표시되고 요소로는 대표적으로 아래와 같다.
  * 사용자 변수
  * NOT-DETERMINISTIC 속성의 스토어드 루틴
  * 결괏값이 호출할 때마다 달라지는 함수

<img src="./그림 10.4.png">

#### 10.3.2.11 UNCACHEABLE UNION
* 캐시 사용이 불가능한 UNION을 의미한다.

#### 10.3.2.12 MATERIALIZED
* 5.6 버전부터 도입됬고, 주로 FROM절이나 IN(subquery) 형태의 쿼리에 사용된 서브쿼리의 최적화를 위해 사용된다.
  * 구체화(MATERIALIZED) 최적화: 세미 조인에 사용된 서브쿼리를 통째로 구체화해서 쿼리를 최적화한다.

### 10.3.3 table 칼럼
* 실행 계획은 단위 SELECT 쿼리 기준이 아니라 테이블 기준으로 표시된다. 테이블의 이름에 별칭이 부여된 경우에는 별칭이 표시된다.
* table 칼럼에 `<>`로 둘러싸인 이름으로 명시될 때 그 테이블은 임시 테이블을 의미한다. <>안에 표시되는 숫자는 단위 SELECT 쿼리의 id값을 지칭한다.

### 10.3.4 partitions 칼럼
* 파티션 생성 시 제약 사항 파티션 키로 사용되는 칼럼은 프라이머리 키를 포함한 모든 유니크 인덱스의 일부여야 한다.
* 파티션이 여러 개인 테이블에서 불필요한 파티션을 빼고 쿼리를 수행하기 위해 접근해야 할 것으로 판단되는 테이블만 골라내는 과정을 파티션 프루닝이라고 한다.
* 파티션을 참조하는 쿼리(파티션 키 칼럼을 WHERE 조건으로 가진)의 경우 옵티 마이저가 쿼리 처리를 위해 필요한 파티션들의 목록만 모아서 실행 계획의 partitions 칼럼에 표시해준다.
* type 칼럼의 값이 ALL(풀 테이블 스캔)인 이유는, 파티션은 물리적으로 개별 테이블처럼 별도의 저장 공간을 가지기 때문이다. 해당하는 파티션만 풀 스캔을 실행한다.

### 10.3.5 type 칼럼
* 실행 계획에서 type 이후의 칼럼은 MySQL 서버가 각 테이블의 레코드를 어떤 방식으로 읽었는지를 나타낸다.
* 쿼리를 튜닝할 때 인덱스를 효율적으로 사용하는지 확인하는 것이 중요하므로 type 칼럼은 반드시 체크해야 한다.
* type 칼럼에 표시될 수 있는 값은 아래와 같다. (성능 빠른 순서)
  * system
  * const
  * eq_ref
  * ref
  * fulltext
  * ref_or_null
  * unique_subquery
  * index_subquery
  * range
  * index_merge
  * index
  * ALL
* ALL을 제외한 나머지 방법은 모두 인덱스를 사용하는 접근 방법으로 ALL은 풀 테이블 스캔이다.
* 하나의 단위 SELECT 쿼리는 접근법 중 단 하나만 사용할 수 있다.
* index_merge를 제외한 방법들은 하나의 인덱스만 사용한다.

#### 10.3.5.1 system
* 레코드가 1건만 존재하거나 아예 없는 테이블을 참조하는 형태의 접근 방법이다.
* InnoDB 스토리지 엔진을 사용하는 테이블에서는 나타나지 않고 MyISAM, MEMORY 테이블에서만 사용된다.

#### 10.3.5.2 const
* 테이블의 레코드 건수와 관계없이 쿼리가 프라이머리 키나 유니크 키 칼럼을 이용하는 WHERE 조건절을 가지고 있으며, 반드시 1건을 반환하는 쿼리의 처리 방식이다. (다른 RDBMS에서는 유니크 인덱스 스캔이라고도 표현)
* 다중 칼럼으로 구성된 프라이머리 키나 유니크 키 중에서 인덱스의 일부 칼럼만 조건으로 사용하면 const 타입의 접근 방식을 사용할 수 없다.
* 옵티마이저가 쿼리를 최적화하는 단계에서 쿼리를 먼저 실행해서 통째로 상수화하는데 그래서 상수(const)라고 표시된다.

#### 10.3.5.3 eq_ref
* 여러 테이블이 조인되는 쿼리의 실행 계획에서만 표시된다.
* 조인에서 처음 읽은 테이블의 칼럼값을 그 다음 읽어야 할 테이블의 프라이머리 키나 유니크 키 칼럼의 검색 조건에 사용할 때, 두 번째 이후에 읽는 테이블의 type 칼럼에 eq_ref가 표시된다.
* 조인에서 두 번째 이후에 읽는 테이블에서 반드시 1건만 존재한다는 보장이 있어야 사용할 수 있는 접근 방법이다.

#### 10.3.5.4 ref
