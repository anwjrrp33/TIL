# 07. 레플리케이션

### 데이터 레플리케이션이란?
일반적으로 쓰기 작업이 있을 때마다 업데이트된 데이터를 다른 서버로 계속 보내 복제하는 것을 말하며 이런 방식을 통해 서버를 추가하고 리소스를 확작해 읽기 쿼리의 부하를 관리할 수 있고 데이터 중복성을 통한 페일오버로 가용성을 얻을 수 있다.

![alt text](image.png)

## 7.1 레플리케이션 기능
단일 노드 방식은 장애, 네트워크 연결 문제, 시스템 충돌 같은 문제에 영향을 쉽게 받기 때문에 실제 운영환경에선 다중 노드로 구성하여 가용성을 확보하고 레디스는 여러 노드로 운영하기 위한 레플리케이션 기능을 제공한다. 

마스터 레플리카 모델에선 지속적으로 마스터의 업데이트 내용을 여러 레플리카에 반영하고 RDBMS에서 사용하는 방식과 유사하며 주요 목적은 `읽기 작업 확장과 고가용성을 위한 중복성 확보`이다.

### 7.1.1 비동기 처리를 통한 구현
레디스의 레플리케이션은 이벤트 루프의 비동기 논블로킹 방식으로 구현되었고 비동기 동작으로 지연이 발생하면 마스터와 레플리카 내의 데이터가 동일하다고 보장할 수 없다.

### 7.1.2 레플리케이션을 사용할 때 레디스를 연결하는 방법
#### 레플리케이션을 사용하는 경우 
각 캐시 노드의 IP 주소나 엔드포인트를 기록해두고 레디스 클라이언트에서 직접 접근하거나 twemproxy 같은 프록시를 활용해 여러 레플리카의 요청 라우팅 과정을 자동화할 수 있다.

#### ElastiCache를 사용하는 경우
클러스터 모드가 비활성화된 레디스 클러스터에서 엔드포인트를 사용할 수 있어서 프록시 등을 준비하고 관리하는 수고가 필요 없다.
* 마스터에 대한 요청 라우팅은 프라이머리 엔드포인트
* 레플리카에 대한 요청 라우팅은 리더 엔드포인트

### 7.1.3 기본적으로 읽기 전용인 레플리카
레플리케이션을 활용할 때 추가된 레플리카를 사용하여 읽기 작업의 부하를 분산하는 방법이 있고 기본적으로 레플리카는 읽기 전용으로 설정되어 있으며, 쓰기 작업을 허용할 수 있지만 이는 데이터 일관성 문제를 초래할 위험이 있다.

특별한 경우를 제외하고는 레플리카에 쓰기 작업을 하지 않는 것이 좋지만 만약 쓰기 작업이 필요하다면 replica-read-only 설정을 통해 변경할 수 있으며 이 역시 신중하게 다뤄야 한다. 또한 클라우드 기반의 관리형 서비스에서는 종종 쓰기 작업이 제한되기도 한다.

### 7.1.4 마이그레이션으로 활용하기
레플리케이션 기능은 새로운 Redis 서버로 마이그레이션할 때 다운타임을 최소화하는 데 유용하게 사용되며 기존 Redis 서버에서 새로운 서버로 레플리케이션을 설정하고 이후 새로운 서버를 독립시켜 마이그레이션을 완료되지만 이 방법을 사용하면 다운타임은 페일오버 시간으로 제한되므로 매우 짧게 유지할 수 있다. 또한, Redis에 내장된 기능이나 RIOT과 같은 제3자 소프트웨어를 활용해 마이그레이션을 수행할 수도 있다.

### 7.1.5 레플리케이션 주의사항
레플리케이션 작업을 실행할 때 마스터에 영속성이 설정되어 있지 않은 경우 엔진을 재실행하거나 종료하면 데이터 세트가 초기화된 상태로 실행되며 레플리카도 초기화됙 떄문에 주의해야 한다.

## 7.2 레플리케이션을 시작할 때의 메커니즘
1. 레플리카는 PSYNC 명령어로 마스터에 연결을 요청하며 해당 시점까지 처리한 레플리케이션 ID와 오프셋을 전송
2. 마스터는 요청받은 마스터의 레플리케이션 ID와 자신의 레플리케이션 ID가 일치하는지 확인하고, 오프셋이 레플리케이션 백로그의 버퍼에 있는지 확인
3. 요청받은 오프셋이 레플리케이션 백로그에 있는지에 따라 처리가 분기
* 레플리케이션 백로그에서 동기화가 가능한 경우
  * 요청된 오프셋이 레플리케이션 백로그에 있고 레플 리케이션 백로그에서 동기화가 가능한 경우에는 부분 동기화를 실행
* 레플리케이션 백로그에서 동기화가 불가능한 경우
  * 레플리케이션 중단 중에 마스터가 받은 쓰기 작업 요청의 크기가 버퍼 크기를 초과하여 부분 동기화가 불가능한 경우에는 전체 동기화를 실행

### 7.2.1 전체 동기화
#### 전체 동기화 메커니즘
1. 레플리카가 마스터에 레플리케이션 시작을 요청
2. 마스터는 BGSAVE 명령어를 실행하여 프로세스를 포크 처리하고 포크된 프로세스에서 메모리 스냅숏(RDB 파일 생성)을 진행
3. BGSAVE 처리가 완료된 후 RDB 파일을 레플리카로 전송하며 그동안 마스터의 쓰기 작업은 레플리카의 클라이언트 출력 버퍼에 기록하며 레플리카는 전송된 RDB 파일을 메모리로 적재
4. RDB 파일 전송이 완료된 후 레플리카의 클라이언트 출력 버퍼에 기록된 데이터를 레플리카로 전송
5. 레플리카의 클라이언트 출력 버퍼에 쓰기 작업이 완료되면 마스터의 쓰기 작업은 실시간으로 레플리카로 계속해서 전송

#### 전체 동기화를 시작할 때의 세부사항
전체 동기화 시, 마스터가 RDB 파일을 전송할 때 레플리카에 기존 파일이 있으면 삭제되며 동기화 중 레플리카는 클라이언트 요청에 이전 데이터를 반환할 수 있으며 이를 방지하려면 `replica-serve-stale-data` 설정을 no로 변경해 요청에 응답하지 않도록 할 수 있다.

#### 여러 개의 레플리카가 있을 때의 동작
여러 레플리카가 마스터에 연결될 때 두 번째 레플리카 이후의 동기화는 마스터에서 BGSAVE 명령이 완료된 시점에 따라 달라지며 BGSAVE가 완료되기 전에 동기화를 요청하면 두 번째 이후의 레플리카는 첫 번째 레플리카와 동일한 데이터를 복제받지만 BGSAVE 완료 후에 요청하면 전체 동기화 과정이 처음부터 다시 시작된다.

#### 레플리케이션 연결이 끊길 때의 동작
레플리카의 클라이언트 출력 버퍼가 초과되면 연결이 끊기고 재동기화가 시도되며 이때, 레플리케이션 백로그에 따라 부분 동기화 또는 전체 동기화가 이루어질 수 있지만 클라이언트 출력 버퍼의 하드 리미트 기본 설정(client-output-buffer-limit replica)은 256MB, 소프트 리미트는 64MB이며, 소프트 리미트를 60초 동안 초과하면 연결이 끊긴다.

#### TTL이 설정된 키의 레플리케이션 동작
TTL이 설정된 키는 레플리카에서 자체적으로 만료되지 않으며 마스터가 DEL 명령어를 통해 레플리카로 전송한다. RDB 파일 덤프 시 만료된 키는 포함되지 않으며 이로 인해 마스터와 레플리카 간에 키 개수 차이가 있을 수 있다. INFO나 DBSIZE 명령어로는 레플리카에서 만료된 키를 확인할 수 없다.

#### 디스크 없는 레플리케이션
디스크 없는 레플리케이션은 RDB 파일을 디스크에 저장하지 않고 소켓을 통해 전송하는 방식이다. 기본적으로 디스크 백업 방식은 메모리 데이터를 RDB 파일로 덤프하여 디스크에 쓰지만, 디스크 속도가 느리면 부하가 클 수 있다. 

디스크 없는 레플리케이션을 활성화하려면 `repl-diskless-sync`를 yes로 설정하며, 추가 레플리카는 기존 작업이 완료될 때까지 기다린다. 기본적으로 5초 대기하며, 이 시간은 `repl-diskless-sync-delay`로 조절할 수 있다. 이 방식은 대규모 데이터 세트 처리와 빠른 네트워크 환경에서 유용하다.

#### 그 외 레플리케이션 최적화를 위한 확인 사항
레플리케이션 최적화를 위해 TCP NODELAY 설정을 비활성화할 수 있다. TCP NODELAY를 비활성화하면 대역폭을 줄일 수 있지만 지연 시간이 증가한다. repl-disable-tcp-nodelay를 yes로 설정하면 된다. 

레플리카 수가 많아지면 마스터 성능에 영향을 줄 수 있으므로 주의가 필요하며 네트워크 대역폭 소비를 고려해 다단계 레플리케이션 구조를 사용할 수 있다.

### 7.2.2 부분 동기화
부분 동기화에서는 레플리케이션 연결이 끊어진 동안의 쓰기 작업이 레플리케이션 백로그에서 레플리카로 전송된다. 백로그는 고정 길이의 메모리 영역으로, 끊어진 연결 동안 쓰기 작업 정보를 일정 시간 동안 보관한다. 백로그 크기는 `repl-backlog-size`로 설정하며 기본값은 1MB이다. 만약 쓰기 작업이 1MB를 초과하면 부분 동기화가 불가능하고 전체 동기화가 진행된다. 

백로그의 보관 시간은 `repl-backlog-ttl`로 설정하며 기본값은 1시간이다. 이 값을 0으로 설정하면 무기한 보관된다. 백로그 크기와 보관 기간을 조절하여 성능을 개선할 수 있으나 메모리 사용량이 증가할 수 있어 주의가 필요하다.

#### 동기식 레플리케이션 강제하기
레디스는 기본적으로 비동기 레플리케이션을 사용하지만, 동기식 레플리케이션을 강제하려면 WAIT 명령어를 사용해야 한다. WAIT 명령어는 클라이언트가 지정한 수의 레플리카로부터 응답을 받을 때까지 차단되며, 데이터 손실을 줄이고 페일오버 시 레플리카를 새로운 마스터로 효율적으로 승격할 수 있다. WAIT는 또한 부분 동기화를 통해 레플리카의 타임아웃을 감지하는 데 도움을 준다. 

비동기 레플리케이션에서는 마스터 장애 시 데이터 손실이 발생할 수 있으므로, 애플리케이션에서 재시도 처리나 다른 데이터베이스와의 연동을 고려해야 한다. 동기화 과정이 성능에 영향을 미칠 수 있으므로 성능에 대한 고려도 필요하다.

## 7.3 레플리케이션 동작 중 메커니즘

### 7.3.1 마스터와 레플리카 간의 연결 상태 모니터링
마스터는 기본적으로 10초 간격으로 레플리카에 핑을 보내며, 이 간격은 `repl-ping-replica-period`로 조절할 수 있다. 레플리카는 매초 `REPLCONF ACK <offset>` 명령어로 핑을 보내고, 마스터는 마지막 핑 시간을 기록하여 레플리케이션 링크의 문제를 조기에 감지한다. 만약 일정 시간 내에 핑이 도착하지 않으면 레플리카는 연결이 끊어진 것으로 인식되며, 이 시간은 `min-replicas-max-lag`로 설정할 수 있으며 기본값은 10초다.

마스터는 최소한의 레플리카 개수를 `min-replicas-to-write`로 설정하여, 이 값을 충족하지 않으면 쓰기 작업을 중단한다. 기본값은 0으로 비활성화되어 있다. 레플리카와의 핑에는 타임아웃이 있으며, 이는 `repl-timeout`으로 조절하고 기본값은 60초다. `repl-ping-replica-period`는 repl-timeout보다 작게 설정해야 하는데 그렇지 않으면 마스터/레플리카 간의 트래픽이 적을 때마다 혹은 repl-timeout 지시자로 설정한 시간이 지날 때마다 레플리케이션 연결이 끊어진다.

## 7.4 페일오버
레디스는 기본적으로 자동 페일오버 기능이 없으며, 마스터가 다운되면 수동으로 새로운 마스터를 승격시켜야 한다. 이를 위해 `REPLICAOF NO ONE` 명령어로 새로운 마스터를 설정하고, `REPLICAOF <new_master_ip> <new_master_port>` 명령어로 레플리카를 새로운 마스터에 연결하거나 설정 파일을 수정해야 한다. 

자동 페일오버 기능은 레디스 클러스터나 레디스 센티널을 사용하거나 관리형 서비스에서 제공될 수 있다. 페일오버 중에는 `CLIENT PAUSE` 명령어를 사용하여 클라이언트의 접근을 일시적으로 중단하고, 새로운 마스터로의 쓰기 작업을 유도할 수 있다.