## 아톰 73. 예외 처리
### 예외 처리
* 코틀린을 기본적인 오류를 찾아주며 컴파일 시점에 감지못하는 경우 실행 시점에 처리해야 한다.
* 최근 동시성이 자주 사용되며, 중요하지 않은 오류가 발생했을 때 동작을 멈추지 않고 계속 실행되어야 하기 때문에 예외가 발생해서 세션이 닫히는 경우 복구할 수 있어야 한다.
* `예외 처리는 세 가지 활동을 합친 것`이다.
  1. 오류 보고
  2. 복구
  3. 자원 해제

### 오류 보고
* 예외를 구체적으로 처리하기 위해 새 예외 타입을 정의할 수 있다.
  ```
  class Exception1(
    val value: Int
  ): Exception("wrong value: $value")

  open class Exception2(
    description: String
  ): Exception(description)

  class Exception3(
    description: String
  ): Exception2(description)
  ```

### 복구
* 예외 처리의 목표는 복구지만, 복구가 불가능 한 경우도 존재한다.
* 예외가 던져지면 예외 처리 매커니즘이 예외를 처리하기에 적절한 위치를 찾고 함수 체인의 위쪽으로 전달되며 해당 과정에서 예외와 일치하는 예외 핸들러가 있으면 예외를 잡는다.
  * 핸들러가 존재하면 검색이 종료되고 핸들러를 실행
  * 핸들러가 존재하지 않으면 콘솔에 스택 트레이스를 출력 후 종료
* 예외 핸들러는 catch 키워드 다음에 예외의 목록을 나열한 후 복구 과정을 구현하는 코드 블록이 온다.
  ```
  try {
    ...
  } catch (e: Exception1) {
    e.value
  } catch (e: Exception3) {
    e.message
  } catch (e: Exception2) {
    e.message
  }
  ```

### 예외 하위 타입
* 다른 상황에서 같은 예외를 쓰면 혼란스러운 오류 메세지를 볼 수 있다.
* 두 예외를 하위 타입으로 만들어 각각 처리하는 핸들러를 생성하면 처리 방식에 따라 다른 예외 타입을 사용해 구분할 수 있다.
* 너무 많은 예외 타입을 만들지 않는 것이 좋으며, 처리 방법이 같은 경우 동일한 예외 타입을 쓰면서 생성자 인자를 다르게 주는 방식으로 구체적인 정보를 전달하는 것이 좋다.

### 자원 해제
* 실패를 피할 수 없을 때 자원을 자동으로 해제하게 만들면 다른 부분이 계속 안전하게 실행되도록 도움이 된다.
* finally는 예외 처리 과정에서 자원을 해제할 수 있게 보장하며, try 블록이 끝나면 항상 finally 절이 실행된다.
  ```
  try {
    trace(value)
    if (value <= 0)
      throw IllegalArgumentException(
        "value must be positive: $value")
  } finally { // 항상 실행되는 블록
    trace("In finally clause for $value")
  }
  ```

### 가이드라인
* 코틀린 예외의 목적은 버그를 발견하는 것이고 예외 복구가 아니며 평범한 코틀린 코드에서 예외를 잡아내는 부분이 있다면 `코드 냄새`다.
* 코틀린에서 예외를 사용하는 경우에 대한 가이드라인
  1. 논리 오류
     * 코드에 있는 버그를 의미
     * 논리 오류와 관련한 예외를 전혀 잡지 않거나, 애플리케이션 최상위 수준에서 예외를 잡고 버그를 보고 
  2. 데이터 오류
     * 프로그래머가 제어할 수 없는 잘못된 데이터에 의해 생긴 오류 → 데이터 타입 오류 및 빈 값 오류
     * 애플리케이션은 어떻게든 이런 오류를 처리해야 하는데, 실패가 예상되는 연사마다 예외를 던지는 버전 대신 `OrNull` 버전이 존재
  3. 검사 명령
     * 논리 오류를 검사
     * 버그를 찾으면 예외를 발생시키며 함수 호출처럼 보여서 코드가 명시적으로 예외를 던질 필요 X
  4. 입출력 오류
     * 제어할 수 없는 외부 조건이지만 무시할 수 없는 오류
     * `OrNull` 방식을 사용하면 코드를 쉽게 이해하며, I/O 오류는 보통 입출력 연산을 다시 시행해서 복구 시도 가능
     * 코틀린의 I/O는 예외를 던지기 때문에 애플리케이션에 예외를 처리하고 복구를 시도하는 코드 포함 필요

## 아톰 74. 검사 명령
### 검사 명령
* 검사 명령은 `만족시켜야 하는 제약 조건을 적은 단언문`이다.
* 함수 인자와 결과를 검증할 때 검사 명령을 사용한다.
* 검사 명령은 요구 사항을 표혐함으로써 프로그래밍 오류를 발견하고, 코드를 읽을 사람들에게 문서 역할을 할 수 있다.
* 함수 맨 앞, 마지막에서 검사 명령을 찾을 수 있고 일반적으로 실패 시 오류를 던진다.
* 검사 명령을 사용하면 코드 작성, 요구 조건 생각이 쉬워지고 작성된 코드를 이해하기 수월해진다.
* 프로그램을 검증하고 코드를 설명하기 위해 가능할 때마다 검사 명령을 사용하는 것이 좋다.

### require()
* 계약에 의한 설계의 사전 조건은 초기화 관련 제약 사항을 보장한다.
* require()는 함수 인자를 검증하기 위해 사용되며 본문 맨 앞에 위치하는 경우가 많다.
* 인자 검증, 사전 조건 검증을 컴파일 시점에 할 수는 없다.
  ```
  // 달력의 달을 표현하는 숫자 필드지만 사전 조건 1..12 사이를 넘어가면 오류를 보고
  data class Month(val monthNumber: Int) {
    init {
      require(monthNumber in 1..12) {
        "Month out of range: $monthNumber"
      }
    }
  }
  ```
* require()은 조건은 만족시키지 못하면 IllegalArgumentException를 반환하며, 두 번째 파라미터는 String을 만들어 내는 람다로 예외를 던지기 전까진 부가 비용이 들지 않는다.

### requireNotNull()
* 첫 번째 인자가 null인지 검사해 널이 아니면 값을 돌려주고, 널이면 IllegalArgumentException가 발생한다.
* requireNotNull()은 널 가능성만 검사하기 때문에 파라미터가 한 개인 버전이 더 유용하다.
  ```
  requireNotNull(n) {
    "notNull() argument cannot be null"
  }
  ```

### check()
* 계약에 의한 설계의 사후 조건은 함수의 결과를 검사한다.
* 결과를 확신할 수 없는 함수에서 사후 조건이 유용하며, 결과에 대한 제약 사항을 묘사해야 하는 경우라면 사후 조건으로 표현하는 것이 좋다.
  ```
  if (create)
    resultFile.writeText("Results\n# ok")
  // ... 다른 실행 경로들
  check(resultFile.exists()) {
    "${resultFile.name} doesn't exist!"
  }
  ```
* 인자가 제대로 들어왔는데 사후 조건이 실패하면 프로그래밍 실수가 있다는 의미로 코드가 올바르면 주석으로 처리하거나 제거하는 것이 좋다. → 사후 조건을 단위 테스트로 옮기기

### assert()
* check() 문을 주석 처리 및 해제하는 assert()를 사용한다.
* 명령줄에서 -ea라는 플래그를 사용해서 활성화/비활성화한다. → 기본은 비활성화
* 설정 없이 사용 가능한 require(), check()를 사용하는 것을 추천한다.