## 아톰 73. 예외 처리
### 예외 처리
* 코틀린을 기본적인 오류를 찾아주며 컴파일 시점에 감지못하는 경우 실행 시점에 처리해야 한다.
* 최근 동시성이 자주 사용되며, 중요하지 않은 오류가 발생했을 때 동작을 멈추지 않고 계속 실행되어야 하기 때문에 예외가 발생해서 세션이 닫히는 경우 복구할 수 있어야 한다.
* `예외 처리는 세 가지 활동을 합친 것`이다.
  1. 오류 보고
  2. 복구
  3. 자원 해제

### 오류 보고
* 예외를 구체적으로 처리하기 위해 새 예외 타입을 정의할 수 있다.
  ```
  class Exception1(
    val value: Int
  ): Exception("wrong value: $value")

  open class Exception2(
    description: String
  ): Exception(description)

  class Exception3(
    description: String
  ): Exception2(description)
  ```

### 복구
* 예외 처리의 목표는 복구지만, 복구가 불가능 한 경우도 존재한다.
* 예외가 던져지면 예외 처리 매커니즘이 예외를 처리하기에 적절한 위치를 찾고 함수 체인의 위쪽으로 전달되며 해당 과정에서 예외와 일치하는 예외 핸들러가 있으면 예외를 잡는다.
  * 핸들러가 존재하면 검색이 종료되고 핸들러를 실행
  * 핸들러가 존재하지 않으면 콘솔에 스택 트레이스를 출력 후 종료
* 예외 핸들러는 catch 키워드 다음에 예외의 목록을 나열한 후 복구 과정을 구현하는 코드 블록이 온다.
  ```
  try {
    ...
  } catch (e: Exception1) {
    e.value
  } catch (e: Exception3) {
    e.message
  } catch (e: Exception2) {
    e.message
  }
  ```

### 예외 하위 타입
* 다른 상황에서 같은 예외를 쓰면 혼란스러운 오류 메세지를 볼 수 있다.
* 두 예외를 하위 타입으로 만들어 각각 처리하는 핸들러를 생성하면 처리 방식에 따라 다른 예외 타입을 사용해 구분할 수 있다.
* 너무 많은 예외 타입을 만들지 않는 것이 좋으며, 처리 방법이 같은 경우 동일한 예외 타입을 쓰면서 생성자 인자를 다르게 주는 방식으로 구체적인 정보를 전달하는 것이 좋다.

### 자원 해제
* 실패를 피할 수 없을 때 자원을 자동으로 해제하게 만들면 다른 부분이 계속 안전하게 실행되도록 도움이 된다.
* finally는 예외 처리 과정에서 자원을 해제할 수 있게 보장하며, try 블록이 끝나면 항상 finally 절이 실행된다.
  ```
  try {
    trace(value)
    if (value <= 0)
      throw IllegalArgumentException(
        "value must be positive: $value")
  } finally { // 항상 실행되는 블록
    trace("In finally clause for $value")
  }
  ```

### 가이드라인
* 코틀린 예외의 목적은 버그를 발견하는 것이고 예외 복구가 아니며 평범한 코틀린 코드에서 예외를 잡아내는 부분이 있다면 `코드 냄새`다.
* 코틀린에서 예외를 사용하는 경우에 대한 가이드라인
  1. 논리 오류
     * 코드에 있는 버그를 의미
     * 논리 오류와 관련한 예외를 전혀 잡지 않거나, 애플리케이션 최상위 수준에서 예외를 잡고 버그를 보고 
  2. 데이터 오류
     * 프로그래머가 제어할 수 없는 잘못된 데이터에 의해 생긴 오류 → 데이터 타입 오류 및 빈 값 오류
     * 애플리케이션은 어떻게든 이런 오류를 처리해야 하는데, 실패가 예상되는 연사마다 예외를 던지는 버전 대신 `OrNull` 버전이 존재
  3. 검사 명령
     * 논리 오류를 검사
     * 버그를 찾으면 예외를 발생시키며 함수 호출처럼 보여서 코드가 명시적으로 예외를 던질 필요 X
  4. 입출력 오류
     * 제어할 수 없는 외부 조건이지만 무시할 수 없는 오류
     * `OrNull` 방식을 사용하면 코드를 쉽게 이해하며, I/O 오류는 보통 입출력 연산을 다시 시행해서 복구 시도 가능
     * 코틀린의 I/O는 예외를 던지기 때문에 애플리케이션에 예외를 처리하고 복구를 시도하는 코드 포함 필요

## 아톰 74. 검사 명령
### 검사 명령
* 검사 명령은 `만족시켜야 하는 제약 조건을 적은 단언문`이다.
* 함수 인자와 결과를 검증할 때 검사 명령을 사용한다.
* 검사 명령은 요구 사항을 표혐함으로써 프로그래밍 오류를 발견하고, 코드를 읽을 사람들에게 문서 역할을 할 수 있다.
* 함수 맨 앞, 마지막에서 검사 명령을 찾을 수 있고 일반적으로 실패 시 오류를 던진다.
* 검사 명령을 사용하면 코드 작성, 요구 조건 생각이 쉬워지고 작성된 코드를 이해하기 수월해진다.
* 프로그램을 검증하고 코드를 설명하기 위해 가능할 때마다 검사 명령을 사용하는 것이 좋다.

### require()
* 계약에 의한 설계의 사전 조건은 초기화 관련 제약 사항을 보장한다.
* require()는 함수 인자를 검증하기 위해 사용되며 본문 맨 앞에 위치하는 경우가 많다.
* 인자 검증, 사전 조건 검증을 컴파일 시점에 할 수는 없다.
  ```
  // 달력의 달을 표현하는 숫자 필드지만 사전 조건 1..12 사이를 넘어가면 오류를 보고
  data class Month(val monthNumber: Int) {
    init {
      require(monthNumber in 1..12) {
        "Month out of range: $monthNumber"
      }
    }
  }
  ```
* require()은 조건은 만족시키지 못하면 IllegalArgumentException를 반환하며, 두 번째 파라미터는 String을 만들어 내는 람다로 예외를 던지기 전까진 부가 비용이 들지 않는다.

### requireNotNull()
* 첫 번째 인자가 null인지 검사해 널이 아니면 값을 돌려주고, 널이면 IllegalArgumentException가 발생한다.
* requireNotNull()은 널 가능성만 검사하기 때문에 파라미터가 한 개인 버전이 더 유용하다.
  ```
  requireNotNull(n) {
    "notNull() argument cannot be null"
  }
  ```

### check()
* 계약에 의한 설계의 사후 조건은 함수의 결과를 검사한다.
* 결과를 확신할 수 없는 함수에서 사후 조건이 유용하며, 결과에 대한 제약 사항을 묘사해야 하는 경우라면 사후 조건으로 표현하는 것이 좋다.
  ```
  if (create)
    resultFile.writeText("Results\n# ok")
  // ... 다른 실행 경로들
  check(resultFile.exists()) {
    "${resultFile.name} doesn't exist!"
  }
  ```
* 인자가 제대로 들어왔는데 사후 조건이 실패하면 프로그래밍 실수가 있다는 의미로 코드가 올바르면 주석으로 처리하거나 제거하는 것이 좋다. → 사후 조건을 단위 테스트로 옮기기

### assert()
* check() 문을 주석 처리 및 해제하는 assert()를 사용한다.
* 명령줄에서 -ea라는 플래그를 사용해서 활성화/비활성화한다. → 기본은 비활성화
* 설정 없이 사용 가능한 require(), check()를 사용하는 것을 추천한다.

## 아톰 75. Nothing 타입
### Nothing 타입
* Nothing은 함수가 결코 반환되지 않는다는 사실을 표현하는 반환 타입이다.
* Nothing은 항상 항상 예외를 던지는 함수의 반환 타입이다.
  ```
  // 무한 루프가 발생되는 함수로 결코 반환되지 않기 때문에 반환 타입이 Nothing
  fun infinite(): Nothing {
    while (ture) {}
  }
  ```
* Nothing은 아무 인스턴스도 없는 코틀린 내장 타입이다.
* `Nothing은 모든 타입과 호환 가능`하다.
* 코틀린에서 fail()은 항상 예외를 던지기 때문에 반환 타입이 Nothing이며, fail()을 호출하는 게 명시적으로 예외를 던지는 것보다 읽기 좋고 간결하다.
* fail()을 사용하면 예외 던지기 전에 추가 메시지 및 로그를 남기는 등의 처리가 가능하다.

## 아톰 76. 자원 해제
### 자원 해제
* try-finally 블록을 써서 자원을 정리하면 실수를 저지르기 쉬우며 코틀린 라이브러리 함수가 대신해 자원을 정리해준다.
* 자원을 닫는 도중에 예외가 발생한다면 finally 블록 안에 다른 try 블록이 필요해져서 제대로 자원을 해제하는 과정이 지저분하다.
* `코틀린이 제공하는 use() 함수를 통해서 닫을 수 있는 자원을 해제`해준다.
* use()는 AutoClosealbe 인터페이스를 구현하는 모든 객체에 적용 가능하며, 객체의 close()를 호출한다.
  * 적용 가능한 객체 문서 참조 - https://docs.oracle.com/javase/8/docs/api/java/lang/AutoCloseable.html
* use()도 모든 예외를 다시 던져주기 때문에 프로그램에서는 여전히 예외를 처리해야 한다.
  ```
  fun main() {
    DataFile("Results.txt")
      .bufferedReader()
      .use { it.readLines().first() } eq
      "Results"
  }
  ```
* useLines()는 파일을 닫고 람다가 반환하는 결과를 반환한다.
  ```
  fun main() {
    DataFile("Results.txt").useLines {
      it.filter { "#" in it }.first()
    } eq "# ok"
    DataFile("Results.txt").useLines { lines ->
      lines.filter { line ->
        "#" in line
      }.first()
    } eq "# ok"
  }
  ```
* forEachLine()은 파일의 각 줄에 대해 작업을 쉽게 적용한다.
  * 전달된 람다는 Unit을 반환하며, 부수 효과를 통해 달성해야 한다는 의미다.
  * 함수형 프로그래밍에선 결과를 반환하는 쪽을 선호하기에 useLines()가 forEachLine()보다 함수형인 접근 방법이지만, 코드는 forEachLine()이 간결하다.
  ```
  fun main() {
    DataFile("Results.txt").forEachLine {
      if (it.startsWith("#"))
        trace("$it")
    }
    trace eq "# ok"
  }
  ```
* AutoClosealbe 인터페이스 안에는 close() 함수만 들어있다.

> use()를 사용하면 자원을 생성하는 시점에 자원 해제를 확실히 보장가능하며, 자원 사용을 끝낸 시점에 직접 자원 해제 코드를 작성할 필요도 없다.

## 아톰 77. 로깅
### 로깅
* 실행 중인 프로그램에서 정보를 얻는 행위이다.
* 로깅은 디버깅할 때 유용하며, 로깅이 없다면 println() 문을 사용해 프로그램의 동작을 해독해야 한다.
* 로깅은 오류를 분석할 수 있는 자세한 정보를 남겨 문제를 복구하고 로깅은 이런 이벤트를 잡아내서 문제를 발견할 수 있는 방법을 제공한다.
* `코틀린 로깅`이라는 오픈 소스 로깅 패키지가 존재한다.
  ```
  private val log = KLogging().logger
  ```
* 로거는 다양한 로깅 수준을 보여준다.
  * trace
  * debug
  * info
  * warn
  * error
* 코틀린 로깅 라이브러리는 SLF4J 위에 만든 퍼사드(Facade)이다.
* 로깅은 라이브러리 함수를 호출하는 것만큼 단순하지 않고, 구성 요소가 상당히 많이 필요하다.
* 서버처럼 장기간 실행되는 프로그램은 로그 파일 관리가 중요하고, 로그 파일이 저장 장치를 가득 채우지 않도록 전략이 필요하다.

## 아톰 78. 단위 테스트
### 단위 테스트
* `함수의 여러 측면에 대해 올바른지 검증하는 테스트를 작성하는 방법을 단위 테스트`라고 하며 단위 테스트를 사용하면 망가진 코드가 빠르게 드러나고 개발 속도가 향상된다.
* 단위 테스트는 프로그래머가 작성하며 프로젝트를 빌드할 때마다 실행되며, 자주 실행되기 때문에 실행 속도가 빨라야 한다.
* 단위 테스트는 JUnit이 유명하고, 코틀린 표준 라이브러리에는 테스트 라이브러리에 대한 퍼사드를 제공하는 kotiln.test가 들어있다.
  ```
  // 코틀린 테스트 관련 의존관계 처리
  implementation(kotlin("test"))
  ```

### 단언문 함수
* assertEquals(), assertNotEquals()
  * 실제 값과 예상 값을 비교
* assertTrue(), assertFalse()
  * 첫 번째 파라미터로 들어온 Boolean 식을 검증
* assertNull(), assertNotNull()
  * 첫 번쨰 파라미터로 들어온 값의 Null 여부 검증
* assertFails(), assertFailsWith()
  * 블록 안에 코드가 에러 발생 여부를 검증

### 테스트 프레임워크
* 테스트 프레임워크는 단언문 함수와 테스트를 실행하고 결과를 표시하기 위한 메커니즘으로 이뤄진다.
* JUnit5 사용 시 build.gradle.kt에 의존성을 추가한다.
  ```
  testImplementation(kotiln("test-junit5"))
  testImplementation("org.junit.platform:junit-platform-launcher")
  testImplementation("org.junit.platform:junit-platform-engine")
  ```
* @Test 애너테이션은 일반 함수를 테스트 함수로 바꿔준다
  ```
  @Test
  fun test() {
    ...
  }
  ```
* 테스트 클래스는 보통 여러 단위 테스트를 포함하며, 이상적인 경우 각 단위 테스트는 한 가지 동작만을 검증해야 단위테스트가 실패했을 때 빠르게 문제 원인을 찾을 수 있다.
* 일반적으로 코틀린은 함수 이름에 글자와 숫자만 허용하지만 역작은따옴표(`)로 감싸면 아무 문장이나 사용 가능하다.
* 단위 테스트의 본질은 복잡한 소프트웨어의 점진적인 개발 과정을 단순화하는 것이며, 새로운 변경사항을 도입할 때 안전한 느낌을 받을 수 있고 시스템을 예측 가능하면서 안정적이게 된다.
* CI를 사용하면 자동으로 모든 테스트를 실행하고 알림도 받을 수 있다.

### 모킹과 통합 테스트
* 다른 요소에 의존하는 시스템으로 인해 격리된 테스트를 만들기 어려워지는 경우 실제 구성 요소를 의존 관계에 추가하는 대신 모킹에 의존한다.
* 목(mock)은 테스트를 실행하는 동안 실물을 대신하는 가짜이며, 무결성을 유지하기 위해 DB를 모킹하는 경우가 많다.
* 실제와 똑같은 인터페이스를 구현한 목을 만들 수도 있고 MockK같은 모킹 라이브러리를 사용해 목을 만든다.
* 기능의 부분은 독립적으로 테스트하는 것이 중요하며 단위 테스트가 그런 역활을 해주는데 하나로 합쳤을 때 검증하는 것도 필수적이며 통합 테스트가 이러한 역할을 한다.
* 단위 테스트는 내부로 향하는 테스트, 통합 테스트는 밖으로 향하는 테스트이다.