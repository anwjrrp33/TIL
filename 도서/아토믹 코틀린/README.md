* 코틀린은 자바를 알고 있으면 쉽게 배울 수 있고 구문이 간결하므로 자바보다 쉽고 간단한 언어라고 생각하기 쉽지만, 실제로는 코틀린도 자바만큼(어쩌면 그보다 더) 복잡한 언어다.
* 코틀린이 제공하는 여러 가지 편의 기능을 제대로 사용하려면 우선 그 바탕이 되는 기본 언어를 깊이 이해해야 한다. 따라서 코틀린을 처음 배울 때 좀 더 제대로 기본 언어를 이해하는 게 중요하다.

### 예제
* [길벗출판사 깃허브](https://github.com/gilbutITbook/080301)
* [지은이(브루스 에켈) 깃허브](https://github.com/BruceEckel/AtomicKotlinExamples)

### 목차
1부 프로그래밍 기초
__01 소개
____이 책의 콘셉트
__02 왜 코틀린인가?
____컴파일러와 인터프리터
____코틀린에 영향을 미친 언어
____왜 코틀린인가? (2011년 출시되고 2016년 버전 1.0이 나온 언어)
____코틀린의 두 가지 특징
__03 Hello, World!
__04 var와 val
__05 데이터 타입
__06 함수
__07 if 식
__08 문자열 템플릿
__09 수 타입
__10 불리언
__11 while로 반복하기
__12 루프와 범위
__13 in 키워드
__14 식과 문
__15 1부 요약

2부 객체 소개
__16 객체는 모든 곳에 존재한다
__17 클래스 만들기
__18 프로퍼티
__19 생성자
__20 가시성 제한하기
____모듈
__21 패키지
__22 테스트
____프로그램의 일부분인 테스트
__23 예외
__24 리스트
____파라미터화한 타입
____읽기 전용과 가변 List
____+=의 비밀
__25 가변 인자 목록
____명령줄 인자
__26 집합
__27 맵
__28 프로퍼티 접근자
__29 2부 요약

3부 사용성
__30 확장 함수
__31 이름 붙은 인자와 디폴트 인자
__32 오버로딩
__33 when 식
__34 이넘
__35 데이터 클래스
____HashMap과 HashSet
__36 구조 분해 선언
__37 널이 될 수 있는 타입
__38 안전한 호출과 엘비스 연산자
__39 널 아님 단언
__40 확장 함수와 널이 될 수 있는 타입
__41 제네릭스 소개
____제네릭 함수
__42 확장 프로퍼티
__43 break와 continue
____레이블

4부 함수형 프로그래밍
__44 람다
__45 람다의 중요성
__46 컬렉션에 대한 연산
__47 멤버 참조
____함수 참조
____생성자 참조
____확장 함수 참조
__48 고차 함수
__49 리스트 조작하기
____묶기
____평평하게 하기
__50 맵 만들기
____맵에 연산 적용하기
__51 시퀀스
__52 지역 함수
____레이블
____지역 함수 조작하기
__53 리스트 접기
__54 재귀

5부 객체 지향 프로그래밍
__55 인터페이스
____SAM 변환
__56 복잡한 생성자
__57 부생성자
__58 상속
__59 기반 클래스 초기화
__60 추상 클래스
__61 업캐스트
__62 다형성
__63 합성
____합성과 상속 중 선택하기
__64 상속과 확장
____관습에 의한 인터페이스
____어댑터 패턴
____멤버 함수와 확장 함수 비교
__65 클래스 위임
__66 다운캐스트
____스마트 캐스트
____변경 가능한 참조
____as 키워드
____리스트 원소의 타입 알아내기
__67 봉인된 클래스
____sealed와 abstract 비교
____하위 클래스 열거하기
__68 타입 검사
____외부 함수에서 타입 검사하기
__69 내포된 클래스
____지역 클래스
____인터페이스에 포함된 클래스
____내포된 이넘
__70 객체
__71 내부 클래스
____한정된 this
____내부 클래스 상속
____지역 내부 클래스와 익명 내부 클래스
__72 동반 객체

6부 실패 방지하기
__73 예외 처리
____오류 보고
____복구
____예외 하위 타입
____자원 해제
____AtomicTest의 예외 처리
____가이드라인
__74 검사 명령
____require()
____requireNotNull()
____check()
____assert()
__75 Nothing 타입
__76 자원 해제
__77 로깅
__78 단위 테스트
____테스트 프레임워크
____모킹과 통합 테스트
____인텔리J IDEA에서 테스트하기

7부 파워 툴
__79 확장 람다
____확장 람다를 사용해 빌더 작성하기
__80 영역 함수
____영역 함수는 인라인된다
__81 제네릭스 만들기
____Any
____제네릭스 정의하기
____타입 정보 보존하기
____타입 파라미터 제약
____타입 소거
____함수의 타입 인자에 대한 실체화
____타입 변성
__82 연산자 오버로딩
____동등성
____산술 연산자
____비교 연산자
____범위와 컨테이너
____컨테이너 원소 접근
____호출 연산자
____역작은따옴표로 감싼 함수 이름
__83 연산자 사용하기
____구조 분해 연산자
__84 프로퍼티 위임
__85 프로퍼티 위임 도구
__86 지연 계산 초기화
__87 늦은 초기화

부록
__A 아토믹 테스트
__B 자바 상호 운용성
____코틀린에서 자바 호출하기
____자바에서 코틀린 호출하기
____자바를 코틀린에 도입하기
____자바의 검사 예외와 코틀린
____널이 될 수 있는 타입과 자바
____널 가능성 애너테이션
____컬렉션과 자바
____자바 원시 타입
__C 인텔리J에서 코틀린 코드를 실행하는 법
____인텔리J IDEA 설치하기
____깃허브에서 예제 내려받기
____인텔리J에서 예제 실행하기
__D 인텔리J에서 이 책의 연습 문제를 푸는 법
____EduTools 플러그인 설치하기
____학습 코스 선택하기
____예제와 연습 문제 실행하기