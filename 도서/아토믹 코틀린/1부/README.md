## 아톰 01. 소개
* 한 장에서 하나의 개념만을 소개하며 각 장을 더 작은 단위로 나누지 못하게 했다.
* 이 책의 각 장을 `아톰(atom)`이라고 부른다.

## 아톰 02. 왜 코틀린인가?
### 그루비(Groovy)
* 값이 없는 경우를 다루는 코틀린 연산자 ?.과 ?:은 그루비에서 처음 사용됐다.

### 가독성
* 코틀린 문법은 간결하며 대부분의 경우 준비 코드 없이 복잡한 아이디어를 표현할 수 있다.

### 도구
* 젯브레인즈가 만든 언어로 최상급의 도구 지원을 받을 수 있으며, 언어 기능이 도구 지원을 염두에 두고 설계됐다.

### 다중 패러다임
* 여러 프로그래밍 패러다임을 지원한다.
  * 명령형 프로그래밍
  * 함수형 프로그래밍
  * 객체지향 프로그래밍

### 다중 플랫폼
* 여러 타깃 플랫폼으로 컴파일할 수 있다.
  * JVM
  * 안드로이드
  * 자바스크립트
  * 네이티브 바이너리

### 코틀린의 두 가지 특징
1. 노력이 필요없는 자바 상호 운용성
   * 코틀린은 하위 호환될 필요없이 JVM에서 제대로 작동해야 할 필요만 있다.
   * 코틀린은 기존 자바 프로젝트에 코틀린을 통합할 수 있으며 작게 코틀린 기능을 작성해서 기존 자바 코드 사이에 끼워 넣을 수 있다.
2. 빈값 표현 방식
   * 존재하지 않는 단어의 뜻을 물어본다면 없는 단어의 의미를 마음대로 만들어내면 항상 결과를 돌려줄 수 있다.
   * 자바는 실행 시점에 오류를 발생시켜 초기화되지 않은 값에 대한 참조를 금지해서 초기화되지 않은 값을 발견할 수 있지만 프로그램에서 초기화되지 않은 값이 있는지 알아내는 유일한 방법이 프로그램을 실행해서 이런 오류가 발생하는지 살펴보는 것뿐이라 널 포인터 문제를 해결 해주지 못하고 자바에선 이런 유형의 버그가 넘쳐난다.
   * 프로그래머는 널 포인트 문제와 같은 오류를 찾기 위해 엄청난 시간을 낭비하고 있지만 코틀린 널 오류를 발생시킬 가능성이 있는 연산을 컴파일 시점에 프로그램이 실행되기도 전에 금지함으로써 이런 문제를 해결해서 자바의 널 오류를 최소화하거나 아예 없앨 수 있으며 코틀린을 채택해야 하는 가장 중요한 특징이다.

## 아톰 03. Hello, World!
### 주석
* // 한줄 짜리 주석
  * // 이후에 있는 모든 내용이 그 줄이 끝날 때까지 무시되며 다음 줄이 시작해야 코틀린은 다시 코드에 신경을 쓴다.
* /* 여러 줄 주석 */
  * 주석이 긴 경우에는 여러 줄 주석을 사용해서 /* 가 시작되고 */로 끝날 때까지 주석이 계속되며 줄이 바뀌는 부분을 새줄 문자라고 부른다.
  * */로 주석을 끝낸 다음에 새 주석을 덧붙여도 되지만 혼동하기 쉬워서 사용하는 경우는 별로 없다.

### 키워드(Keyword) 언어
* 키워드는 언어에 의해 예약되어 있고 특별한 의미를 지니는 단어를 뜻한다.
* fun은 function을 줄인 단어다.
* 함수란 함수 이름을 사용해 실행될 수 있는 코드 모음을 뜻한다.
* main()은 사실 특별한 의미를 가진 함수로 코틀린 프로그램의 진입점(entry point)을 뜻하며, 프로그램을 실행하면 main()이 자동으로 호출된다.
* 함수 이름 뒤에는 파라미터 목록(parameter list)이 온다.

### 세미클론
* 코틀린은 다른 언어와 달리 식 끝에 세미클론을 붙이지 않아도 된다.
* 한 줄 안에 여러 식을 넣고 싶을 때만 식과 식 사이에 세미클론 넣으면 되지만 이런 식의 코드는 권장하지 않는다.

> 주석은 코드만 보고 분명히 알 수 없는 정보를 덧붙이기 위해 쓰이며 단순히 코드의 내용을 반복 한다면 사람들은 짜증을 내며 주석을 무시하게 된다.
> 프로그래머가 코드를 바꾸면서 주석 내 용을 함께 바꾸는 것을 잊어버릴 때도 있기 떄문에 주석은 주의 깊게 사용해야 하며 코드에 서 어려운 부분을 자세히 설명하기 위해 사용하는 것이 좋다.

## 아톰 04. var 와 val
### 식별자
* 식별자(identifier)는 프로그램을 이루는 요소를 가리키기 위해 사용한다.
* 데이터를 가리키는 식별 자를 사용할 때는 가장 기본적으로 선택해야 하는 사항이 있다.
  * 프로그램을 실행하는 동안 변화
  * 단 한 번만 어떤 값을 지정하면 되는지 여부

### 변경 가능성 제어를 위한 두 가지 키워드
* var
  * 변할 수 있는 수(variable)의 약자로, 내용을 재대입할 수 있다.
  * `var 식별자 = 초기화`
  * 시작은 유니코드 문자 또는 밑줄
  * 두 번째 글자부터는 유니코드 문자, 밑줄, 숫자 모두 사용 가능
  ```
  // var 정의
  fun main() {
    var whole = 11
    var fractional = 1.4
    var words = "Twas Brillig"
    println(whole)
    printin(fractional)
    println(words)
  }
  // 출력
  11
  1.4
  Twas Brillig
  ```
  * var에 저장된 값은 달라질 수 있고 var 변수를 가변(mmable)이다.
  ```
  // var 가변
  fun main() {
    var sum = 1 
    sum = sum + 2 
    sum += 3 
    println(sum)
  // 출력
  6
  ```
* val
  * 값(value)의 약자로，식별자의 값을 단 한 번만 초기화할 수 있고 일단 값을 초기화하고나면 내용을 변경할 수 없다.
  * `val 식별자 = 초기화`
  * val은 값을 뜻하며, 값이란 변할 수 없는 것을 가리키는데 val 변수는 불변(immable)이다.
  ```
  // val 선언
  fun main() {
    val whole = 11
    // whole = 15 // 오류 발생! 
    val fractional = 1.4
    val words = "Twas Brillig" 
    println(whole) 
    println(fractional) 
    println(words)
  }
  // 출력
  11
  1.4
  Twas Brillig
  ```
  * val을 초기화하고 나면 재대입할 수 없는데 다른 값을 대입하려고 시도하면 코틀린이 `val을 재대입할 수 없음(val cannot be reassigned)`이라고 불평한다.

> 식별자에 이름을 불일 때 서술적인 이름을 붙이면 코드를 이해하기도 쉽고 주석을 추가 할 필요성도 줄어든다.

### var과 val의 장단점
* var는 프로그램이 실행될 때 변경되어야만 하는 값을 표현할 때 유용하며 `프로그램이 실행되 면서 변경되어야 한다`라는 명제는 자주 있음직한 요구 조건으로 보이지만, 실전에서는 피해갈 수 있다.
* 일반적으로 val만 사용하면 프로그램을 확장하고 유지 보수하기가 더 쉬워지지만, 문제를 해결하기에 너무 복잡해지는 경우도 존재한다.
* 코틀린에서는 var도 허용해 유연성을 제공한다.

> val과 시간을 보내다 보면, 프로그램에서 var가 필요한 경우가 거의 없다는 사실과 var를 사용하지 않으면 프로그램이 더 안전해지고 신뢰성도 높아진다는 사실을 알게 된다.

## 아톰 05. 데이터 타입
### 타입
* 코틀린에서는 소수를 Double이라 부르고, 정수를 Int라 부른다.
* 타입(type, 데이터 타입)은 대상 데이터를 어떤 식으로 사용할 지를 코틀린에게 말한다.
* 타입은 어떤 식이 취할 수 있는 값의 집합을 제공하는데 데이터에 대해 적용할 수 있는 연산, 데이터의 의미, 타입에 속한 값을 (컴퓨터 메모리에) 저장하는 방식을 정의한다.
```
// 숫자 + 문자 덧셈
fun main() { 
  println("Sally" + 5.9)
}
// 출력
Sally5.9
```
* 타입을 아래와 같이 조합하면 코틀린이 이해하지 못해서 오류를 표시한다.
```
// 숫자 + 문자 곱셈
fun main() { 
  println("Sally" * 5.9) // 에러 발생
}
```
* 장황하게 타입을 지정할 수 있다.
  * `var 식별자: 타입 = 초기화`
* val, var 키워드로 시작하고 뒤에 식별자, 콜론, 타입, =, 초기화가 온다.
  ```
    // 코틀린 자동 타입 추론
    val n = 1 // Int
    var p = 1.2 // Double
    // 타입을 명시적으로 지정
    val n: Int = 1
    var p: Double = 1.2
  ```

### 코틀린의 기본 타입
1. 소수점 이하 부분이 없는 Int 데이터 타입은 정수(integer)
2. 소수가 있는 데이터 타입은 실수(Double)
3. 특별한 값 true와 false만 저장할 수 있는 Boolean 데이터 타입
4. 큰 따옴표로 둘러 싼 문자로 이뤄진 시퀀스를 저장할 수 있는 String 데이터 타입
5. 한 문자만 담을 수 있는 Char 데이터 타입
6. 여러 줄에 걸친 문자열을 만들거나 특수 문자가 들어간 문자열을 만들어야 하는 경우 큰 따옴표 세개(""")로 감싸며 삼중 큰따옴표 String, 로(raw) String 데이터 타입
```
fun main() {
  val whole: Int = 11 // [1]
  val fractional: Double = 1.4 // [2]
  val trueOrFalse: Boolean = true // [3]
  val words: String = "A value" // [4]
  val character: Char = 'z' // [5]
  val lines: String = """Triple quotes let
      |you have many lines 
      |in your string""".trimMargin() // [6]
  println(whole)
  println(fractional)
  println(trueOrFalse)
  println(words)
  println(character)
  println(lines)
}
// 출력
11
1.4
true
A value
z
Triple quotes let
you have many lines 
in your string
```

### 코틀린 타입 추론
* 코틀린은 타입 추론을 사용해 전체 문장이나 식의 의미를 결정한다.
```
// 타입 추론
fun main() {
  val n = 1 + 1.2
  pringln(n)
}
// 출력
2.2
```
1. n을 계산할 때 코틀린이 타입 추론을 사용해 Double이라 결정한다.
2. 생성된 결과가 Double에 대한 규칙을 준수하는지 확인한다.

> 코틀린의 타입 추론을 프로그래머를 돕기 위한 코틀린의 전략 중 하나로 타입을 지정하지 않아도 보통은 코톨린이 타입을 추론해준다.

## 아톰 06. 함수
> 함수(function)는 이름이 있는 작은 프로그램과 같으며, 다른 함수에서 그 이름으로 실행하거나 호출(invoke)할 수 있다.

### 함수
* 함수는 일련의 동작을 묶어주고 프로그램을 체계적으로 구성하고 코드를 재사용하는 가장 기본적인 방법이다.
* 함수에 정보를 전달하면 함수는 정보를 이용해 계산을 수행해 결과를 만든다.
  ```
  // 함수의 기본적인 형태
  fun 함수이름(p1: 타입1, p2: 타입2, ...): 반환타입 {
    여러 줄의 코드(한 줄 또는 빈 줄)
    return 결과
  }
  ```

### 파라미터
* p1, p2는 함수에 전달할 `파라미터`이다.
* 파라미터 이름으로 쓰일 식별자(p1, p2), 콜론, 파라미터의 타입으로 이루어진다.
* 파라미터는 함수에 정보를 전달하는 방법을 정의한다.

### 함수 본문
* 함수 본문에 있는 코드는 중괄호({})로 둘러싸인다.
* return 키워드 뒤에 오는 식은 함수가 끝날 때 만들어낼 결과를 뜻한다.

### 함수 시그니처
* 파라미터는 전달할 정보를 넣을 장소이며 인자는 함수에 전달하는 실제 값이다.
* 이름 파라미터, 반환 타입을 합쳐서 `함수 시그니처`라고 부른다.

### 코드 재사용 도구
1. fun 키워드, 함수 이름, 파라미터 목록
2. 함수 본문, return을 통해서 값을 함수 결과로 반환한다.
3. 함수에 인자를 넘겨서 호출하고 결과 값을 val r이라는 변수에 넣는다.
```
fun multiplyByTwo(x: Int): Int { // [1]
  printIn("Inside multiplyByTwo") // [2]
  return x * 2
}

fun main() {
  val r = multiplyByTwo(5) // [3]
  println(r)
}
```
* 함수 호출은 함수 코드를 실행하고 결괏값을 가져온다는 사실을 줄여 쓴 것이며 이것이 함수가 프로그래밍에서 가장 기본적인 단순화 도구이자 `코드 재사용 도구인 이유`다.
* println(r)도 함수 호출이며, println이 코틀린이 제공하는 함수라는 점으로 코틀린이 정의한 함수는 `표준 라이브러리 함수`라 부른다.

### 반환 타입 Unit
* Unit은 의미 있는 결과를 제공하지 않는 함수의 반환 타입이다.
* Unit을 명시해도 되지만, 코틀린에서는 Unit을 생략해도 된다.
```
fun sayHello() {
  println("Hallo!")
}

fun sayGoodbye(): Unit {
  priintln("Auf Wiedersehen!")
}

fun main() {
  sayHello()
  sayGoodbye()
}
// 출력
Hallo!
Auf Wiedersehen!
```

### 본문
* 함수 본문이 하나의 식으로만 이뤄진 경우 등호(=) 뒤에 식을 넣어서 함수를 짧게 작성할 수 있다.
  * `fun 함수이름(p1: 타입1, p2: 타입2, ...): 반환타입 = 식`
* 함수 본문이 중괄호로 둘러싸인 경우를 `블록 본문`이라고 한다.
* 등호 뒤에 식이 본문으로 지정된 경우를 `식 본문`이라 한다.
* 코틀린은 식 본문의 반환 타입만 추론하며, 블록 본문에서 반환 타입을 명시하지 않으면 Unit으로 인식한다.

> 함수를 작성할 때는 서술적인 이름을 사용해야 코드를 쉽게 읽어 주석을 남길 필요성을 줄인다.

## 07. if 식